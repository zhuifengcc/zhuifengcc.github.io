<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="沐奕">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="沐奕">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="沐奕">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>沐奕</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">沐奕</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/28/NoSQL：Redis基础及常用数据类型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhuifengcc">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沐奕">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/28/NoSQL：Redis基础及常用数据类型/" itemprop="url">NoSQL:Redis基础及常用数据类型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-28T16:12:37+08:00">
                2019-12-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NoSql/" itemprop="url" rel="index">
                    <span itemprop="name">NoSql</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Redis常用命令"><a href="#Redis常用命令" class="headerlink" title="Redis常用命令"></a>Redis常用命令</h2><h3 id="Redis键key"><a href="#Redis键key" class="headerlink" title="Redis键key"></a>Redis键key</h3><p>DEL key<br>该命令用于在key存在时删除key<br>DUMP key<br>序列化给定key，并返回序列化的值<br>EXISTS key<br>检查给定key是否存在<br>EXPIRE key seconds<br>为给定key设置过期时间（以s计）<br>    ps: 应用场景<br>    1.限时的优惠活动信息<br>    2.网站数据缓存（对于一些需要定时更新的数据，例如：积分排行榜）<br>    3.手机验证码<br>    4.限制网站访客访问频率（例如：1分钟最多访问10次），限制登陆了之后多少秒可以再次登陆（过期时间）<br>PEXPIRE key milliseconds<br>为给定key设置过期时间（以ms计）<br>TTL key<br>以s为单位，返回给定key的剩余生存时间（time to live）<br>PTTL key<br>以ms为单位返回key的剩余的过期时间<br>PERSIST key<br>移除key的过期时间，key将持久保持<br>KEYS pattern<br>查找所有符合给定模式（pattern）的key<br>keys 通配符  获取所有与pattern匹配的key，返回所有与该匹配<br> 通配符:</p>
<pre><code>* 代表所有
? 表示代表一个字符
</code></pre><p> ps: 如当前有3个key(users:1,users:2,users:3) 可以通过keys users:?查询<br>RANDOMKEY<br>从当前数据库中随机返回一个key<br>RENAME key newkey<br>修改key的名称<br>MOVE key db<br>将当前数据库的key移动到指定的数据库db中<br>TYPE key<br>返回key所存储的值的类型</p>
<h3 id="key的命名建议"><a href="#key的命名建议" class="headerlink" title="key的命名建议"></a>key的命名建议</h3><pre><code>1.key不要太长，尽量不要超过1024子节，这不仅消耗内存，而且会降低查找的效率
2.key也不要太短，太短的话，key的可读性会降低
3.在一个项目中，key最好使用统一的命名模式，例如: user:123:password
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/02/Spring Cloud：Spring Cloud Sleuth/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhuifengcc">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沐奕">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/02/Spring Cloud：Spring Cloud Sleuth/" itemprop="url">Spring Cloud: Spring Cloud Sleuth</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-02T00:07:02+08:00">
                2018-09-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring-Cloud/" itemprop="url" rel="index">
                    <span itemprop="name">Spring Cloud</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>随着微服务业务壮大，各种服务调用非常复杂，几乎每一个前端请求都会形成一条负载的分布式服务调用链路，途中任何一个服务失败都可能造成最后失败，所以整个链路追踪非常重要。Sleuth则时这样一个人分布式服务最终的解决方法。</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><p>首先我们先搭建一个环境，需要的服务有：<br>eureka-server<br>微服务1，实现一个/trace-1接口，调用这个接口将触发对trace-2应用的调用<br>pom引入ribbon、web、eureka、sleuth<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-sleuth&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleuthApplication</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(SleuthApplication.class);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SleuthApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/trace-1"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">trace</span><span class="params">()</span></span>&#123;</span><br><span class="line">        logger.info(<span class="string">"------call trace1--------------"</span>);</span><br><span class="line">        <span class="keyword">return</span> restTemplate().getForEntity(<span class="string">"http://trace2/trace-2"</span>,String.class).getBody();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=trace1</span><br><span class="line">server.port=<span class="number">9101</span></span><br><span class="line">eureka.client.serviceUrl.defaultZone=http:<span class="comment">//localhost:1111/eureka</span></span><br></pre></td></tr></table></figure></p>
<p>微服务2<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sleuth2Application</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(Sleuth2Application.class);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Sleuth2Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/trace-2"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">trace</span><span class="params">()</span></span>&#123;</span><br><span class="line">        logger.info(<span class="string">"------call trace2--------------"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Traced"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们启动，访问trace-1.可以看到控制台info的消息<br>INFO [trace1,e6032bd804035fe4,e6032bd804035fe4,false] 19800 — [nio-9101-exec-1] com.cg.sleuth.SleuthApplication : ——call trace1————–</p>
<p>INFO [trace2,e6032bd804035fe4,7af75df6c4f9693c,false] 11272 — [nio-9102-exec-1] com.cg.sleuth2.Sleuth2Application : ——call trace2————–</p>
<p>上述info种trace1为应用名，第二个值为Sleuth生成的ID(Trace ID)，标记请求链路，第三个值为sleuth生成的另一个id(Span ID)，表示一个基本的工作单元，比如发送一个HTTP请求，false表示是否输出到ziplin收集展示</p>
<h2 id="跟踪原理"><a href="#跟踪原理" class="headerlink" title="跟踪原理"></a>跟踪原理</h2><p>请求发送到分布式系统入口端点时，sleuth为该请求创建一个唯一标识，分布式系统内部流转时，始终传递该唯一表示，直到返回给请求方。通过traceID，可以将请求过程的日志关联起来<br>为了统计各个单元处理时间延迟，当请求到达服务时，通过唯一标识(SpanID)来标记他的开始及结束。<br>引入sleuth后，可以自动为当前应用构建起各种通信通道的最终机制：如rabbitMQ传递请求、zuul代理传递请求、restTemplate请求</p>
<p>上述示例通过restTemplate实现，sleuth会对该请求追踪</p>
<h2 id="抽样收集"><a href="#抽样收集" class="headerlink" title="抽样收集"></a>抽样收集</h2><p>追踪通过trace ID和span ID实现了，但是分布式系统加入对所有进行追踪，将产生海量日志数据，对性能造成影响，日志储存开销也很大。之前的第四个值就是用来代表该信息是否要被后续的跟踪信息收集器获取和储存。<br>sleuth通过Sampler接口实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sampler</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSampled</span><span class="params">(Span span)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过该接口，sleuth会再产生跟踪信息的时候生成是否要被收集的标志。<br>默认情况下，sleuth会使用PercentageBasedSampler来实现抽样策略，可以在applicatino.properties中配置，默认10%收集</p>
<pre><code>spring.sleuth.sampler.percentage=0.1
</code></pre><p>不过开发测试阶段一般设置为1</p>
<h2 id="Logstash整合"><a href="#Logstash整合" class="headerlink" title="Logstash整合"></a>Logstash整合</h2><p>之前实现了通过日志添加跟踪信息的功能，但是，在海量的日志文件中去排查分析是基本不可能的。<br>一般的日志分析平台有ELK，可以轻松搜索出我们想要的明细日志。<br>ELK 平台由ElesticSearch、Logstash、Kibana组成</p>
<pre><code>ElesticSearch:开源分布式搜索引擎。分布式、零配置，自动发现。。。
Logstash：对日志进行收集过滤，并将其储存
Kibana ： 结合上面两个，提供日志分析web界面
</code></pre><p> spring cloud 与ELK整合时候，只需要和Logstash对接数据即可，为Logstaash提供json格式的日志输出。</p>
<h2 id="整合过程"><a href="#整合过程" class="headerlink" title="整合过程"></a>整合过程</h2><p>1.pom引入logstash-logback-encoder依赖<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;net.logstash.logback&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;logstash-logback-encoder&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p>2./resource下创建bootstrap.properties配置文件，将spring.application.name=trace-1配置移动到该文件里，因为logback-spring.xml在application.properties之前加载</p>
<p>3./resource下创建logback-spring.xml.<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;include resource=<span class="string">"org/springframework/boot/logging/logback/defaults.xml"</span>/&gt;</span><br><span class="line">    &lt;springProperty scope=<span class="string">"context"</span> name=<span class="string">"springAppName"</span> source=<span class="string">"spring.application.name"</span>/&gt;</span><br><span class="line">    &lt;!-- 日志在工程中的输出位置 --&gt;</span><br><span class="line">    &lt;property name=<span class="string">"LOG_FILE"</span> value=<span class="string">"$&#123;BUILD_FOLDER:-build&#125;/$&#123;springAppName&#125;"</span>/&gt;</span><br><span class="line">    &lt;!-- 控制台的日志输出样式 --&gt;</span><br><span class="line">    &lt;property name=<span class="string">"CONSOLE_LOG_PATTERN"</span></span><br><span class="line">            value=<span class="string">"%clr(%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr([$&#123;springAppName:-&#125;,%X&#123;X-B3-TraceId:-&#125;,%X&#123;X-B3-SpanId:-&#125;,%X&#123;X-Span-Export:-&#125;])&#123;yellow&#125; %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;"</span>/&gt;</span><br><span class="line">    &lt;!-- 控制台Appender --&gt;</span><br><span class="line">    &lt;appender name=<span class="string">"console"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span><br><span class="line">        &lt;filter <span class="class"><span class="keyword">class</span></span>=<span class="string">"ch.qos.logback.classic.filter.ThresholdFilter"</span>&gt;</span><br><span class="line">            &lt;level&gt;INFO&lt;/level&gt;</span><br><span class="line">        &lt;/filter&gt;</span><br><span class="line">        &lt;encoder&gt;</span><br><span class="line">            &lt;pattern&gt;$&#123;CONSOLE_LOG_PATTERN&#125;&lt;/pattern&gt;</span><br><span class="line">            &lt;charset&gt;utf8&lt;/charset&gt;</span><br><span class="line">    &lt;/encoder&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 为logstash输出的json格式的Appender --&gt;</span><br><span class="line">    &lt;appender name=<span class="string">"logstash"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span><br><span class="line">        &lt;file&gt;$&#123;LOG_FILE&#125;.json&lt;/file&gt;</span><br><span class="line">        &lt;rollingPolicy <span class="class"><span class="keyword">class</span></span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span><br><span class="line">            &lt;fileNamePattern&gt;$&#123;LOG_FILE&#125;.json.%d&#123;yyyy-MM-dd&#125;.gz&lt;/fileNamePattern&gt;</span><br><span class="line">            &lt;maxHistory&gt;7&lt;/maxHistory&gt;</span><br><span class="line">        &lt;/rollingPolicy&gt;</span><br><span class="line">        &lt;encoder <span class="class"><span class="keyword">class</span></span>=<span class="string">"net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder"</span>&gt;</span><br><span class="line">            &lt;providers&gt;</span><br><span class="line">                &lt;timestamp&gt;</span><br><span class="line">                    &lt;timeZone&gt;UTC&lt;/timeZone&gt;</span><br><span class="line">                &lt;/timestamp&gt;</span><br><span class="line">                &lt;pattern&gt;</span><br><span class="line">                    &lt;pattern&gt;</span><br><span class="line">                        &#123;</span><br><span class="line">                        <span class="string">"severity"</span>: <span class="string">"%level"</span>,</span><br><span class="line">                        <span class="string">"service"</span>: <span class="string">"$&#123;springAppName:-&#125;"</span>,</span><br><span class="line">                        <span class="string">"trace"</span>: <span class="string">"%X&#123;X-B3-TraceId:-&#125;"</span>,</span><br><span class="line">                        <span class="string">"span"</span>: <span class="string">"%X&#123;X-B3-SpanId:-&#125;"</span>,</span><br><span class="line">                        <span class="string">"exportable"</span>: <span class="string">"%X&#123;X-Span-Export:-&#125;"</span>,</span><br><span class="line">                        <span class="string">"pid"</span>: <span class="string">"$&#123;PID:-&#125;"</span>,</span><br><span class="line">                        <span class="string">"thread"</span>: <span class="string">"%thread"</span>,</span><br><span class="line">                        <span class="string">"class"</span>: <span class="string">"%logger&#123;40&#125;"</span>,</span><br><span class="line">                        <span class="string">"rest"</span>: <span class="string">"%message"</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &lt;/pattern&gt;</span><br><span class="line">                &lt;/pattern&gt;</span><br><span class="line">            &lt;/providers&gt;</span><br><span class="line">        &lt;/encoder&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line">    &lt;root level=<span class="string">"INFO"</span>&gt;</span><br><span class="line">        &lt;appender-ref ref=<span class="string">"console"</span>/&gt;</span><br><span class="line">        &lt;appender-ref ref=<span class="string">"logstash"</span>/&gt;</span><br><span class="line">    &lt;/root&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></p>
<p>启动完成，访问/trace-1接口，可以看到工程目录下的build文件夹下的json记录</p>
<h2 id="Zipkin整合"><a href="#Zipkin整合" class="headerlink" title="Zipkin整合"></a>Zipkin整合</h2><p>ELK缺少对请求链路中各个阶段时间延迟的关注，使用zipkin可以解决。<br>zippkin基于google Dapper，可以使用它来收集各个服务器上请求链路的跟踪数据，并通过它提供的REST API接口来辅助对分布式系统的监控程序。</p>
<p><img src="https://raw.githubusercontent.com/wiki/zhuifengcc/zhuifengcc.github.io/images/Spring Cloud/Spring Cloud Sleuth/7-1.png" alt="架构图"></p>
<p>Collector：收集器组件，处理从外部系统发送过来的跟踪信息，转换为Zipkin内部处理的Span格式<br>Storage：存储组件，它主要对处理收集器接收到的跟踪信息，默认会将这些信息存储在内存中，也可以使用其他存储组件将跟踪信息存储到数据库中。<br>RESTful API：API组件，它主要用来提供外部访问接口。比如给客户端展示跟踪信息，或是外接系统访问以实现监控等。<br>Web UI：UI组件，基于API组件实现的上层应用。用户可以方便而有直观地查询和分析跟踪信息。</p>
<h2 id="整合流程"><a href="#整合流程" class="headerlink" title="整合流程"></a>整合流程</h2><p>1） 直接下载zipkin jar 直接启动，是一个spring boot 应用<br>2） trace-1 trace-2添加spring-cloud-sleuth-zipkin依赖<br>3） 在application.properties中增加zipkinserver配置信息</p>
<pre><code>spring.zipkin.base-url=http://localhost:9411
</code></pre><p>可以在zipkin页面看到 <a href="http://localhost:9411" target="_blank" rel="noopener">http://localhost:9411</a></p>
<h2 id="整合消息中间件，收集消息，ELK处理储存Hbase；或者流计算，实时呈现"><a href="#整合消息中间件，收集消息，ELK处理储存Hbase；或者流计算，实时呈现" class="headerlink" title="整合消息中间件，收集消息，ELK处理储存Hbase；或者流计算，实时呈现"></a>整合消息中间件，收集消息，ELK处理储存Hbase；或者流计算，实时呈现</h2><p>就是这一套技术。<br>1）<br>trace-1 trace-2添加spring-cloud-sleuth-stream<br>application.properties去除zipkin url参数，并配置rabbitmq信息<br>2）<br>zipkin-server 引入zipkin-stream依赖，</p>
<p>最后，我们使用之前的验证方法，通过向trace-1的接口发送几个请求：<a href="http://localhost:9101/trace-1" target="_blank" rel="noopener">http://localhost:9101/trace-1</a> ,当有被抽样收集的跟踪信息时（调试时我们可以设置AlwaysSampler抽样机制来让每个跟踪信息都被收集），我们可以在RabbitMQ的控制页面中发现有消息被发送到了sleuth交换器中，同时我们再到zipkin服务端的Web页面中也能够搜索到相应的跟踪信息，那么我们使用消息中间件来收集跟踪信息的任务到这里就完成了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/22/Spring Cloud：Spring Cloud Stream/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhuifengcc">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沐奕">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/22/Spring Cloud：Spring Cloud Stream/" itemprop="url">Spring Cloud: Spring Cloud Stream</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-22T00:06:41+08:00">
                2018-08-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring-Cloud/" itemprop="url" rel="index">
                    <span itemprop="name">Spring Cloud</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>消息队列，应用在spring cloud之中大概有两个。<br>一个是stream作为服务之间的通信MQ，一个是bus是关于广播配置的，都基于rabbit和kafka。<br>那么什么是消息队列，为什么需要消息队列？</p>
<p>简单的来说，打个比方，一个话多的女朋友给一个木讷的男朋友发信息。<br>女生发送信息非常快，巴拉巴拉的发，而男生不懂女生的心思，十多分钟才能弄明白女生的一条信息。<br>如果没有收件箱，要等男的看完一个，消息却不停涌入，男生会崩溃。<br>可以把我们的消息队列当作收件箱，男生处理完一条信息，再去都下一条信息。</p>
<h2 id="举几个消息队列的应用实例"><a href="#举几个消息队列的应用实例" class="headerlink" title="举几个消息队列的应用实例"></a>举几个消息队列的应用实例</h2><p>就是用来解耦，只要保证消息格式不变，消息的发送方和接收方并不需要彼此联系，也不需要受对方的影响，作为一个中间件的存在，接收和分发消息。应用场景举个例子如下</p>
<p>假设用户在你的软件中注册，服务端收到用户的注册请求后，它会做这些操作：</p>
<p>校验用户名等信息，如果没问题会在数据库中添加一个用户记录<br>如果是用邮箱注册会给你发送一封注册成功的邮件，<br>手机注册则会发送一条短信分析用户的个人信息，以便将来向他推荐一些志同道合的人，<br>或向那些人推荐他发送给用户一个包含操作指南的系统通知等等……<br>但是对于用户来说，注册功能实际只需要第一步，只要服务端将他的账户信息存到数据库中他便可以登录上去做他想做的事情了。至于其他的事情，非要在这一次请求中全部完成么？值得用户浪费时间等你处理这些对他来说无关紧要的事情么？所以实际当第一步做完后，服务端就可以把其他的操作放入对应的消息队列中然后马上返回用户结果，由消息队列异步的进行这些操作。</p>
<p>实际上很多地方需要：</p>
<pre><code>上述的异步处理，提升系统响应性能
应用解耦，接收者可以随意增加，不影响发布者，消息发送成功不影响消息接收者
最终一致性：先写消息再操作，操作完成后再修改状态（订单系统与库存系统的一致性）
广播：只需要关心是否发送到消息队列，下游怎么接受是下游的事情
流量削峰：上下游处理能力有差距时，承担一个缓冲地带的功能。（秒杀抢购，请求先存放在消息队列，等待服务器处理）
日志：利用kafaka，解决大量日志传输；（获取用户id，浏览器，ip等信息，通过flume日志收集器进行收集，传到MQ之中——进行流计算并可视化呈现，或者是进行归档，离线计算 处理后存到mysql）
通信：可以单纯作为点对点队列或者聊天室
</code></pre><p>我们之前讲到，SpringCloudConfig通过refresh执行，刷新客户端配置，微服务的客户端越来越多的时候，每个客户端都需要执行一下refresh，这样是不是很不合适，我们现需要消息代理，构建一个公用的消息主题让所有微服务连接上来，该主题的消息会被所有实例监听和消费，所以称为消息总线。</p>
<p>讲到这，消息队列和消息总线有什么区别？</p>
<p>消息总线是基于一个已经相当成熟的消息队列或者消息系统做二次封装</p>
<pre><code>消息队列clientAPI权限太大，clientAPI信任级别太高
消息队列clientAPI面向技术，消息总线clientAPI面向技术+业务
消息队列无法隐藏通信细节
消息队列无法实施实时管控
总线的优势：统一入口，简化拦截成本
</code></pre><p>各种消息队列：ActiveMQ、RabbitMQ、Kafka、RocketMQ<br>spring cloud bus 支持RabbitMQ、Kafka。</p>
<h2 id="RabbitMQ实现"><a href="#RabbitMQ实现" class="headerlink" title="RabbitMQ实现"></a>RabbitMQ实现</h2><p>AMQP（高级 消息 队列 协议）的实现，面向消息的中间件，性能高，由Erlang编写</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><pre><code>Broker：消息队列服务器实体，接受消息发送者的笑意，然后发送给接收者或者其他Broker
Exchange：消息交换机，消息第一个到达地方，消息通过他指定的路由规则进行分发
Queue：消息发送通过路由后最终到达地，进去队列等待消费
Binding：将Exchange和Queue按路由规则绑定起来
Channal：消息通道，用于连接发送接受消息的逻辑结构，每个Channal代表一个会话任务
</code></pre><p>消息队列过程：</p>
<pre><code>客户端连接到消息队列服务器，打开一个Channal
客户端声明Exchange
客户端声明Queue
客户端Binding Exchange和Queue
发送消息
Exchange根据Binding进行消息路由，将消息投递到一个或多个Queue。echange有几种类型：Direct、topic、fanout
</code></pre><p>RabbitMQ支持消息持久化，包括Exchange持久化、Queue持久化、消息持久化</p>
<h3 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h3><p>首先我们需要下载RabbitMQ和Erlang，然后安装他们。 rabbitmq自带管理后台，安装后需要配置开启</p>
<pre><code>rabbitmq-plugins enable rabbitmq_management
</code></pre><p>*重启rabbitmq服务</p>
<pre><code>rabbitmq-server stop
rabbitmq-server start
</code></pre><p>进入管理页面 <a href="http://localhost:15672" target="_blank" rel="noopener">http://localhost:15672</a> guest guest 进入Admin选项卡，创建一个springcloud用户，tags是Rabbit角色分类，给管理员角色</p>
<p>virtual hosts管理，相当于数据库，可以通过右侧virtual host进入进行添加，以/ 开头，可以进行用户授权</p>
<p>进入管理界面，可以进行set permission操作 Web 控制台会展示很多 RabbitMQ 信息，但最最重要的就一个：Unacked Message。这个数据会直接显示在登录之后的 Overview 标签中，第一眼就能看到。Unacked Message 指的是还没有被处理的消息。正常情况下，这个值应该为 0。如果这个值不是 0，并且持续增长，那你就得注意了，这意味着 RabbitMQ 出现了问题，队列开始积压，消息开始堆积，是一个严重的信号.</p>
<h3 id="quick-start"><a href="#quick-start" class="headerlink" title="quick start"></a>quick start</h3><p>Spring Boot整合RabbitMQ，实现一个最小化的发送接受消息的例子。</p>
<p>1) 新建rabbitmq-hello工程，pom引入spring-boot-starter-amqp</p>
<p>2）三个类Config、send、reciever</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">Queue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloSender</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String context = <span class="string">"hello "</span> + <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(<span class="string">"Sender : "</span> + context);</span><br><span class="line">        <span class="keyword">this</span>.rabbitTemplate.convertAndSend(<span class="string">"hello"</span>, context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloReceiver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String hello)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Receiver  : "</span> + hello);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3）配置<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=spirng-boot-rabbitmq</span><br><span class="line">spring.rabbitmq.host=localhost</span><br><span class="line">#连接rabbit的端口为5672.15672是管理页面的端口</span><br><span class="line">spring.rabbitmq.port=<span class="number">5672</span></span><br><span class="line">spring.rabbitmq.username=springcloud</span><br><span class="line">spring.rabbitmq.password=***</span><br></pre></td></tr></table></figure></p>
<p>4）启动主类，连接上</p>
<p>5) 编写测试类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMqHelloTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloSender helloSender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        helloSender.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行测试类，可看到发送和接受消息</p>
<h3 id="原生实现实例"><a href="#原生实现实例" class="headerlink" title="原生实现实例"></a>原生实现实例</h3><h4 id="1、rabbit6大之simple-queues"><a href="#1、rabbit6大之simple-queues" class="headerlink" title="1、rabbit6大之simple queues"></a>1、rabbit6大之simple queues</h4><p>以下均在amqp项目中测试<br>P ———— queue ———— C<br>我们用java来实现一个简单队列，有一个发送消息和一个消费消息的，来发送一个hello world<br>1）建立一个maven项目，引入依赖 rabbitmq client<br>2）获取Mq连接工具类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionUtils</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getCon</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//建立连接工厂及连接属性（继承项目会做配置的，这里直接写在代码里）</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">"/vh"</span>);</span><br><span class="line">        factory.setUsername(<span class="string">"springcloud"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">        <span class="comment">//获取连接--创建channel</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3）Provider<br>这里做一个循环发送消息的测试，运行send，可以看到消息队列运行的情况；同时可以进入Queues页签，点击Get Messages，可以获取message信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Utils.ConnectionUtils;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        sendmess();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">sendmess</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;</span><br><span class="line">        Channel channel=ConnectionUtils.getChan();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        String message = <span class="string">"Hello!"</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">            channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            System.out.println(<span class="string">" [x] Sent '"</span> + message + <span class="string">"&#123;&#125;'"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4）Consumer<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = ConnectionUtils.getChan();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//一旦又消息进入队列，就会触发消费者handleDelivery方法</span></span><br><span class="line">        DefaultConsumer consumer=<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String msg=<span class="keyword">new</span> String(body,<span class="string">"utf-8"</span>);</span><br><span class="line">                System.out.println(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//监听队列，第二个参数是autoack自动应答，返回一个到达的信息，表示已经消费掉了消息，如果不加</span></span><br><span class="line">        <span class="comment">//消息会继续存在再消息队列中造成积压</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">true</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2、rabbit6大之Work-queues"><a href="#2、rabbit6大之Work-queues" class="headerlink" title="2、rabbit6大之Work queues"></a>2、rabbit6大之Work queues</h4><p>P ———— queue ————|——— C1<br>P ———— queue ————|——— C2<br>P ———— queue ————|——— C3<br>P ———— queue ————|——— C4</p>
<p>上面的只有一个消费者，且消费者生产者耦合再一起，多个消费者无法消费，如果队列名变更了，是不是P/C都要变更<br>1)工作队列-轮询分发<br>接上面一个，我们来一个发送者，两个接收者，一个接收者线程100ms中断一个200ms中断，看看消费情况<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        sendmess();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">sendmess</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;</span><br><span class="line">        Channel channel=ConnectionUtils.getChan();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            String message = <span class="string">"Hello!"</span>;</span><br><span class="line">            message+=i;</span><br><span class="line">            channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">" [x] Sent '"</span> + message + <span class="string">"&#123;&#125;'"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = ConnectionUtils.getChan();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//一旦又消息进入队列，就会触发消费者handleDelivery方法</span></span><br><span class="line">        DefaultConsumer consumer=<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">//super.handleDelivery(consumerTag, envelope, properties, body);</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                String msg=<span class="keyword">new</span> String(body,<span class="string">"utf-8"</span>);</span><br><span class="line">                System.out.println(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//监听队列</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">true</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = ConnectionUtils.getChan();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//一旦又消息进入队列，就会触发消费者handleDelivery方法</span></span><br><span class="line">        DefaultConsumer consumer=<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">//super.handleDelivery(consumerTag, envelope, properties, body);</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                String msg=<span class="keyword">new</span> String(body,<span class="string">"utf-8"</span>);</span><br><span class="line">                System.out.println(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//监听队列</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">true</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到消费端被均匀分发，无论消费端的处理能力，消息被均分了</p>
<p>2)工作队列-公平分发<br>rabbit将发送一条给消费者，等待消费者处理应答，处理完成再发下一条，按照处理能力发送了<br>使用此模式，acsk自动应答必须改为手动<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        sendmess();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">sendmess</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;</span><br><span class="line">        Channel channel=ConnectionUtils.getChan();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//告知队列,每次只发一条，消费者处理确认前不再发送</span></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">            String message = <span class="string">"Hello!"</span>;</span><br><span class="line">            message+=i;</span><br><span class="line">            channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">" [x] Sent '"</span> + message + <span class="string">"&#123;&#125;'"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Channel channel = ConnectionUtils.getChan();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//一旦又消息进入队列，就会触发消费者handleDelivery方法</span></span><br><span class="line">        DefaultConsumer consumer=<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">//super.handleDelivery(consumerTag, envelope, properties, body);</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    String msg=<span class="keyword">new</span> String(body,<span class="string">"utf-8"</span>);</span><br><span class="line">                    System.out.println(msg);</span><br><span class="line">                    channel.basicAck(envelope.getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//监听队列,关闭自动应答</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">false</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Channel channel = ConnectionUtils.getChan();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//一旦又消息进入队列，就会触发消费者handleDelivery方法</span></span><br><span class="line">        DefaultConsumer consumer=<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">//super.handleDelivery(consumerTag, envelope, properties, body);</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">20</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    String msg=<span class="keyword">new</span> String(body,<span class="string">"utf-8"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"consumer2"</span>+msg);</span><br><span class="line">                    channel.basicAck(envelope.getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//监听队列,关闭自动应答</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">false</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到控制台打印的信息，两个消费者不再平均分配任务了</p>
<p>3)自动应答与持久化<br>上面的自动应答设置可以改写如下，清晰点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> autoAsk=<span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//监听队列,关闭自动应答</span></span><br><span class="line">channel.basicConsume(QUEUE_NAME,autoAsk,consumer);</span><br></pre></td></tr></table></figure></p>
<p>（自动应答true，自动确认模式）自动应答的含义：消息投递到消费者后，消息从内存中删掉。（这种情况下可能会丢失处理中的消息！消息队列发出消息后，删除消息，但是消费者处理时发生崩溃，消息丢失）</p>
<p>（自动应答false，手动模式）一个消费者挂了，超时未收到回执，则将消息发送给另一个消费者，消费者处理完毕后，发送成功回执，消息队列删除消息。但是加入我们消息队列服务器挂了，我们的消息仍然丢失，这时候我们需要消息持久化</p>
<p>rabbitMQ消息持久化：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是否持久化</span></span><br><span class="line"><span class="keyword">boolean</span> duravle=<span class="keyword">false</span>;</span><br><span class="line">channel.queueDeclare(QUEUE_NAME, duravle, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></p>
<p>将程序中的false改为true，无法生效还会报错，因为消息队列channel只能声明一次，已经定义好了，（可以从控制台删了再次声明，或者新建一个channel）</p>
<h4 id="3、rabbit6大之Publish-Subscribe"><a href="#3、rabbit6大之Publish-Subscribe" class="headerlink" title="3、rabbit6大之Publish/Subscribe"></a>3、rabbit6大之Publish/Subscribe</h4><p>之前的都是被一个消费者消费，发送一条，被消费者争抢。</p>
<p>现在我们需要多个消费者，发送一条消息，让所有消费者都能消费。可以采用订阅模式</p>
<pre><code>work队列：一个队列对应多个消费者
P ———— queue ——— | ——— C1
P ———— queue ——— | ——— C2
P ———— queue ——— | ——— C3
P ———— queue ——— | ——— C4
订阅模式：引入交换机，需要将队列绑定到交换机。一个交换机对应多个队列，一个队列对应一个消费者
P ——x—— |—queue1 ——— |— C1
P ——x—— |—queue2 ——— |— C2
P ——x—— |—queue3 ——— |— C3
P ——x—— |—queue4 ——— |— C4
</code></pre><p>应用场景：注册完成—发送邮件与短信；或者修改商品—更改搜索引擎，同时修改库存，前台信息<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"test_exchange"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        sendmess();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">sendmess</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;</span><br><span class="line">        Channel channel=ConnectionUtils.getChan();</span><br><span class="line">        <span class="comment">//设置分发类型为fanout</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME,<span class="string">"fanout"</span>);</span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        String msg=<span class="string">"hello ps"</span>;</span><br><span class="line">        <span class="comment">//发送到exchange</span></span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME,<span class="string">""</span>,<span class="keyword">null</span>,msg.getBytes());</span><br><span class="line">        channel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过以上代码，我们可以进入控制台exhcange页签，看到test_exchange，但是消息已经丢失了。<br>因为rabbitMQ只有队列又存储能力，而没有队列绑定到exchange，所以数据丢失了。<br>我们需要添加消费者，通过队列绑定exchange，接受消息<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer1</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"test_queue_fanout_email"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"test_exchange"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Channel channel = ConnectionUtils.getChan();</span><br><span class="line">    channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//绑定到exhcnage</span></span><br><span class="line">    channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,<span class="string">""</span>);</span><br><span class="line">    <span class="comment">//消费消息</span></span><br><span class="line">    DefaultConsumer consumer=<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            String msg=<span class="keyword">new</span> String(body,<span class="string">"utf-8"</span>);</span><br><span class="line">            System.out.println(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//监听队列</span></span><br><span class="line">    channel.basicConsume(QUEUE_NAME,<span class="keyword">true</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer1</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"test_queue_fanout_sms"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"test_exchange"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Channel channel = ConnectionUtils.getChan();</span><br><span class="line">    channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//绑定到exhcnage</span></span><br><span class="line">    channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,<span class="string">""</span>);</span><br><span class="line">    <span class="comment">//消费消息</span></span><br><span class="line">    DefaultConsumer consumer=<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            String msg=<span class="keyword">new</span> String(body,<span class="string">"utf-8"</span>);</span><br><span class="line">            System.out.println(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//监听队列</span></span><br><span class="line">    channel.basicConsume(QUEUE_NAME,<span class="keyword">true</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，可以看到均受到了消息。</p>
<h4 id="4、rabbit6大之Routing"><a href="#4、rabbit6大之Routing" class="headerlink" title="4、rabbit6大之Routing"></a>4、rabbit6大之Routing</h4><p>消息增加一个key，只把消息转到相应key的队列。如下，key=”error”,会路由到所有队列；key=”info”，只路由到queue2</p>
<pre><code>p—x(type=direct)—|—error—|—-queue1 —- c1
p—x(type=direct)—|–info —-|↘
p—x(type=direct)—|–error —|→ –queue2— c2
p—x(type=direct)—|–warning–|↗
</code></pre><p>exchange：<br>1.匿名转发(之前演示的)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明交换机 fanout不处理路由键，只需要将队列绑定到交换机，和exchange绑定的队列均能收到消息</span></span><br><span class="line">channel.exchangeDeclare(EXCHANGE_NAME,<span class="string">"fanout"</span>);</span><br><span class="line">channel.basicPublish(EXCHANGE_NAME,<span class="string">""</span>,<span class="keyword">null</span>,msg.getBytes());</span><br></pre></td></tr></table></figure></p>
<p>2.处理路由键<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明交换机 处理路由键 Direct，消息增加一个key，只把消息转到相应key的队列</span></span><br><span class="line">channel.exchangeDeclare(EXCHANGE_NAME,<span class="string">"fanout"</span>);</span><br><span class="line">channel.basicPublish(EXCHANGE_NAME,<span class="string">""</span>,<span class="keyword">null</span>,msg.getBytes());</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"test_exchange_direct"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        sendmess();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">sendmess</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;</span><br><span class="line">        Channel channel= ConnectionUtils.getChan();</span><br><span class="line">        <span class="comment">//设置分发类型为fanout</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME,<span class="string">"direct"</span>);</span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        String msg=<span class="string">"hello direct"</span>;</span><br><span class="line">        String routingKey=<span class="string">"error"</span>;</span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME,routingKey,<span class="keyword">null</span>,msg.getBytes());</span><br><span class="line">        channel.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"test_queue_direct_1"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"test_exchange_direct"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = ConnectionUtils.getChan();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//绑定到exhcnage,并设置routingKey</span></span><br><span class="line">        String routingKey=<span class="string">"error"</span>;</span><br><span class="line">        channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,routingKey);</span><br><span class="line">        <span class="comment">//消费消息</span></span><br><span class="line">        DefaultConsumer consumer=<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String msg=<span class="keyword">new</span> String(body,<span class="string">"utf-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">""</span>+msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//监听队列</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">true</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5、rabbit6大之Topics"><a href="#5、rabbit6大之Topics" class="headerlink" title="5、rabbit6大之Topics"></a>5、rabbit6大之Topics</h4><p>Topics:将路由和某个模式匹配，用符号来表示 #匹配一个或多个；*匹配一个</p>
<pre><code>p—x(type=topic)— |—.orange.—|—-queue1 —- c1
p—x(type=topic)— |–..rabbit —-|↘
p—x(type=topic)— |–lazy.# —|→ –queue2— c2
p—x(type=topic)— |–warning–|↗
</code></pre><p><img src="https://raw.githubusercontent.com/wiki/zhuifengcc/zhuifengcc.github.io/images/Spring Cloud/Spring Cloud Stream/6-3.png" alt="topic模式示意图"></p>
<p>生产者发布 删除 修改 查询 商品</p>
<p>c1 只收某一个发布</p>
<p>c2 收所有发布<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"test_exchange_topic"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        sendmess();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">sendmess</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Channel channel= ConnectionUtils.getChan();</span><br><span class="line">        <span class="comment">//设置分发类型为fanout</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME,<span class="string">"topic"</span>);</span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        String msg=<span class="string">"添加 iphone x"</span>;</span><br><span class="line">        String routingKey=<span class="string">"goods.add"</span>;</span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME,routingKey,<span class="keyword">null</span>,msg.getBytes());</span><br><span class="line">        System.out.println(<span class="string">"发送了"</span>+msg);</span><br><span class="line">        channel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"test_queue_topic_1"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"test_exchange_topic"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = ConnectionUtils.getChan();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//绑定到exhcnage,并设置routingKey</span></span><br><span class="line">        <span class="comment">//消费者1只能拿添加的消息</span></span><br><span class="line">        String routingKey=<span class="string">"goods.add"</span>;</span><br><span class="line">        channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,routingKey);</span><br><span class="line">        <span class="comment">//消费消息</span></span><br><span class="line">        DefaultConsumer consumer=<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String msg=<span class="keyword">new</span> String(body,<span class="string">"utf-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">""</span>+msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//监听队列</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">true</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"test_queue_topic_2"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"test_exchange_topic"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = ConnectionUtils.getChan();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//绑定到exhcnage,并设置routingKey</span></span><br><span class="line">        <span class="comment">//消费者2拿所有商品操作消息</span></span><br><span class="line">        String routingKey=<span class="string">"goods.#"</span>;</span><br><span class="line">        channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,routingKey);</span><br><span class="line">        <span class="comment">//消费消息</span></span><br><span class="line">        DefaultConsumer consumer=<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String msg=<span class="keyword">new</span> String(body,<span class="string">"utf-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">""</span>+msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//监听队列</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">true</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6、rabbit6大之Rpc"><a href="#6、rabbit6大之Rpc" class="headerlink" title="6、rabbit6大之Rpc"></a>6、rabbit6大之Rpc</h4><p>之前几个例子都是再本地执行。RPC是指远程过程调用，也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。<br>其实RPC的方式就是springcloud使用rabbit的方式，前面SpringCloudConfig接受git flow的refresh消息实现动态刷新即是一个示例，不过我们用的封装号的AmqpTemplate实现而已.</p>
<p>rabbitMQ消息确认机制<br>rabbitMQ可以通过持久化解决服务器异常造成的数据丢失问题。而生产者发送消息后，消息到底有没有到达服务器，默认情况是不知道的。要知道消息到达服务器一般有如下两种方式</p>
<p>AMQP实现了事务机制 Confirm模式</p>
<p>1）AMQP实现了事务机制（类似于数据库）</p>
<p><em>txSelect    用户将当前channel设置成transation模式
</em>txCommit    提交<br>*rxRollback  回滚</p>
<p>示例代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TxSend</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"queue_tx"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Channel channel= ConnectionUtils.getChan();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        String msg=<span class="string">"hello tx message"</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//开启事务</span></span><br><span class="line">            channel.txSelect();</span><br><span class="line">            channel.basicPublish(<span class="string">""</span>,QUEUE_NAME,<span class="keyword">null</span>,msg.getBytes());</span><br><span class="line">            <span class="comment">//模拟抛出异常</span></span><br><span class="line">            <span class="keyword">int</span> x=<span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">            channel.txCommit();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            channel.txRollback();</span><br><span class="line">            System.out.println(<span class="string">"fail to send! rollback"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        channel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"queue_tx"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Channel channel= ConnectionUtils.getChan();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">true</span>,<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String msg=<span class="keyword">new</span> String(body,<span class="string">"utf-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">""</span>+msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2）Confirm模式</p>
<p>上面的事务模式发送消息，去的消息的消息确认机制。走协议路径，其实大大降低了消息吞吐量！<br>confirm模式则不会。<br>实现原理</p>
<pre><code>生产者将channel设置未comfirm模式，所有的消息都有唯一的id，一旦消息投递到所有匹配到队列后，rabbit会回执一条消息，使得生产者知道消息发送成功
</code></pre><p>comfirm模式最大的优势就是异步处理！不像AMQP走串行模式</p>
<p>编程模式：<br>*普通 发送一条 waitForConfirms()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"queue_confirm_1"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;</span><br><span class="line">        Channel channel= ConnectionUtils.getChan();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//将channel设为confirm模式</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        String msg=<span class="string">"confirm msg"</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">""</span>,QUEUE_NAME,<span class="keyword">null</span>,msg.getBytes());</span><br><span class="line">        <span class="comment">//如果没收到confirm，说明发送失败</span></span><br><span class="line">        <span class="keyword">if</span>(!channel.waitForConfirms())&#123;</span><br><span class="line">            System.out.println(<span class="string">"message send failed!"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"success!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        channel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"queue_confirm_1"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel= ConnectionUtils.getChan();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">true</span>,<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String msg=<span class="keyword">new</span> String(body,<span class="string">"utf-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">""</span>+msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>*批量 发送一批 waitForConfirms</p>
<p>如果丢失一条，整批都失败，需要重发</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"queue_confirm_1"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;</span><br><span class="line">        Channel channel= ConnectionUtils.getChan();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//将channel设为confirm模式</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        String msg=<span class="string">"confirm msg"</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            channel.basicPublish(<span class="string">""</span>,QUEUE_NAME,<span class="keyword">null</span>,msg.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没收到confirm，说明发送失败</span></span><br><span class="line">        <span class="keyword">if</span>(!channel.waitForConfirms())&#123;</span><br><span class="line">            System.out.println(<span class="string">"message send failed!"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"success!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        channel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>*异步 提供回调,进行监听</p>
<p>channel对象提供ConfirmListener()回调方法只包含deliverTag（消息的序列号）,我们需要为每个channel维护一个unconfirm的消息序列号集合，每publish一个数据，集合元素增加1，每会跳一次handleAck方法，unconfirm集合删掉相应的一条或多条记录。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncSend</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"queue_confirm_3"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;</span><br><span class="line">        Channel channel= ConnectionUtils.getChan();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将channel设为confirm模式</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        <span class="comment">//存放未确认的消息</span></span><br><span class="line">        <span class="keyword">final</span> SortedSet&lt;Long&gt; confirmSet= Collections.synchronizedSortedSet(<span class="keyword">new</span> TreeSet&lt;Long&gt;());</span><br><span class="line">        channel.addConfirmListener(<span class="keyword">new</span> ConfirmListener() &#123;</span><br><span class="line">            <span class="comment">//handNack 回执有问题</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleNack</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(multiple)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"---handleNack---multiple"</span>);</span><br><span class="line">                    confirmSet.headSet(deliveryTag+<span class="number">1</span>).clear();</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"---handleNack---multiple false"</span>);</span><br><span class="line">                    confirmSet.remove(deliveryTag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//没有问题的handleAck</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleAck</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(multiple)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"---handleAack---multiple"</span>);</span><br><span class="line">                    confirmSet.headSet(deliveryTag+<span class="number">1</span>).clear();</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"---handleAack---multiple false"</span>);</span><br><span class="line">                    confirmSet.remove(deliveryTag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        String msg=<span class="string">"confirm msg"</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">long</span> seqNo=channel.getNextPublishSeqNo();</span><br><span class="line">            confirmSet.add(seqNo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="整合到Spring-Cloud里的用法"><a href="#整合到Spring-Cloud里的用法" class="headerlink" title="整合到Spring Cloud里的用法"></a>整合到Spring Cloud里的用法</h2><p>之前讲了rabbit的原生用法，现在我们要结合spring cloud Stream使用</p>
<h3 id="Qucik-Start"><a href="#Qucik-Start" class="headerlink" title="Qucik Start"></a>Qucik Start</h3><p>基于springboot 构建一个微服务，使用消息中间件rabbitMQ接受消息并打印到日志。</p>
<p>1）建立stream-hello工程</p>
<p>2）pom导入<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.0.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p>3)建立消息接受类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableBinding</span>(Sink.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SkinReceiver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@StreamListener</span>(Sink.INPUT)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Object payload)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"recieved"</span>+payload);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4)主类不变，然后启动。不需要做任何配置！</p>
<p>可以看到控制台的Connections多了一条，我们通过Queues里的发布消息来发布一条，<br>可以看到程序控制台打印了</p>
<pre><code>recieved[B@6a001153
</code></pre><p>我们来看一下是如何实现的。</p>
<p>1.spring boot应用引入stream-rabbit的依赖，是stream对rabbitMQ的支持的封装，包含了对rabbitMQ的自动配置等内容；等价于stream-binder-rabbit</p>
<p>2.Stream的核心注解被定义在SinkReciever中</p>
<pre><code>1.@EnableBinding用来注解一个或多个定义了@Input @Output的接口。我们绑定了Sink接口，这个接口是spring cloud stream默认实现输入消息的绑定通道
含义就是这个类绑定了一个input通道
2.@StreamListener
通过该注解将receive方法注册为input通道的监听处理器，在rabbit发布消息的时候，receive会做出相应的相应动作
</code></pre><h4 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h4><p>Spring Cloud Stream结构图。</p>
<p><img src="https://raw.githubusercontent.com/wiki/zhuifengcc/zhuifengcc.github.io/images/Spring Cloud/Spring Cloud Stream/6-4.png" alt="Stream结构图"><br>Stream构建的应用程序与消息中间件是通过Binder关联起来，实现中间件与应用程序的解耦。对于每一个Stream来说，只需要知道Binder对应用程序提供的抽象概念Channel来使用消息中间件来实现逻辑即可</p>
<h5 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h5><p>各个消息中间件差异较大，如果没有Binder这一层，消息交互将变得很笨重，对具体中间件实现细节依赖严重。有了Binder，只需要暴露统一的Channel通道，更换消息队列也只需要更换对应的Binder即可。</p>
<p>而且快速入门的时候，并没有做任何rabbit配置。秉承了spring boot的理念，对rabbit做了自动化配置。当然我们也可以修改</p>
<pre><code>spring.cloud.stream.binding.input.destination=raw-sensor-data
spring.rabbitmq.host=localhost
spring.rabbitmq.port=5672
spring.rabbitmq.username=qx
spring.rabbitmq.password=123456
</code></pre><h5 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h5><p>stream消息通信遵循了发布订阅。一条消息投递到中间件后，会通过通向topic主题进行广播，订阅者收到它并触发自身的业务逻辑进行处理。不同的消息中间件topic对应不用的概念</p>
<p>rabbitmq中topic对应exchange网关</p>
<p>kafka中topic对应topic</p>
<p>1）quick start中，我们通过channel发布消息给应用程序。</p>
<p>2）stream应用启动时候，@EnableBinding(Skin.class)</p>
<p>在rabbitmq的exchange中也创建了一个名为input的exchange交换器，我们可以在控制台看到</p>
<p>3）我们通过不同端口号启动两个示例程序，可以看到exchange中input里绑定了两个channel</p>
<p>这种模式就是之前的那个rabbit6大模式之中的topic模式，消息通过exchange，exchange上绑定了多个不同的队列，一个队列对应一个接受方</p>
<h5 id="Consumer-Group"><a href="#Consumer-Group" class="headerlink" title="Consumer Group"></a>Consumer Group</h5><p>微服务架构中，实际上每一个微服务应用为了高可用和负载均衡，均会部署多个实例。</p>
<p>这种情况下，消息生产者发送消息给某个具体微服务实例时，只希望被消费一次，但是像刚才那种启动两个实例，消息会被消费两次。这时候我们需要用到消费组这个概念。</p>
<p>如果一个服务有多个实例的时候，我们可以通过配置</p>
<pre><code>spring.cloud.stream.bindings.input.group
</code></pre><p>为其制定一个组名。只有一个成员真正接收消息并处理，而不会出现多次处理的情况。</p>
<p>实际应用最好给服务指定一个消费组，防止消费重复处理！除非那种全局都需要处理的情况，比如刷新配置</p>
<p>消息分区</p>
<p>通过消费组，可以使消息只被一个实例处理，但是无法控制被哪个实例使用。情况就是，同一个消息，多次到达后可能被不同的机器消费处理。这种情况对与一些需要事务控制或者用于持续报告的监控服务时，会将数据分散到各个节点而导致不一致性，这种情况需要进行消息分区。</p>
<p>这种分区通过stream提供的通用的抽象实现，所有对于消息中间件是否支持分区不关心。</p>
<p>通过配置</p>
<p>1）消费者配置</p>
<pre><code>spring.cloud.stream.bindings.input.destination 开启分区
spring.cloud.stream.instanceConut=2 指定当前消费组实例数量
spring.cloud.stream.instanceInedex 设置当前实例索引号
</code></pre><p>2）生产消息也需要配置相应修改</p>
<pre><code>spring.cloud.stream.bindings.output.destination 开启分区
spring.cloud.stream.bindings.output.producer.partitionKeyExpression=payload
spring.cloud.stream.bindings.output.producer.partitionCount=2
</code></pre><h3 id="kafaka-安装配置"><a href="#kafaka-安装配置" class="headerlink" title="kafaka 安装配置"></a>kafaka 安装配置</h3><p>我们再cent 7上来进行</p>
<p>1需要jdk，在这使用openjdk</p>
<pre><code>rpm -qa |grep java
rpm -qa |grep jdk
rpm -qa |grep gcj
如果没有输入信息表示没有安装。
如果安装可以使用rpm -qa | grep java | xargs rpm -e --nodeps 批量卸载所有带有Java的文件  这句命令的关键字是java
首先检索包含java的列表
yum list java*
检索1.8的列表
yum list java-1.8*
安装1.8.0的所有文件
yum install java-1.8.0-openjdk* -y
使用命令检查是否安装成功
java -version
</code></pre><p>2.下载kafka</p>
<p>*解压</p>
<pre><code>tar -zxvf kafka_2.10-0.10.0.1.tgz
</code></pre><p>*移动到指定目录</p>
<pre><code>mv kafka_2.10-0.10.0.1 /usr/local/kafka
</code></pre><p>*启动zookeeper</p>
<pre><code>/usr/local/kafka/bin/zookeeper-server-start.sh -daemon /usr/local/kafka/config/zookeeper.properties
</code></pre><p>*启动kakfka</p>
<pre><code>/usr/local/kafka/bin/kafka-server-start.sh /usr/local/kafka/config/server.properties
</code></pre><p>*创建topic</p>
<pre><code>/usr/local/kafka/bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test
</code></pre><p>*产生消息</p>
<pre><code>/usr/local/kafka/bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test

hello kafka！
</code></pre><p>*消费消息</p>
<pre><code>/usr/local/kafka/bin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic test --from-beginning
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/20/Spring Cloud：Spring Cloud Bus/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhuifengcc">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沐奕">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/20/Spring Cloud：Spring Cloud Bus/" itemprop="url">Spring Cloud: Spring Cloud Bus</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-20T23:55:52+08:00">
                2018-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring-Cloud/" itemprop="url" rel="index">
                    <span itemprop="name">Spring Cloud</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>基于rabbit和kafka。一个是stream作为服务之间的通信MQ，一个是bus主要用来关于广播配置的。</p>
<p>Bus是一个轻量级的消息代理，不同于stream作为服务与服务间的通信。Bus让所有服务连接上来，该主题的消息会被所有实例监听消费，所以我们叫他消息总线。</p>
<p>消息总线上的各个实例可以方便地广播一些需要让其他连接都知道得消息，比如配置信息或者一些操作管理，通常用来广播配置，实现动态刷新配置。</p>
<h2 id="RabbitMQ实现消息总线"><a href="#RabbitMQ实现消息总线" class="headerlink" title="RabbitMQ实现消息总线"></a>RabbitMQ实现消息总线</h2><p>一、整合spring cloud bus动态刷新配置</p>
<p>1）准备：config-repo、config-server-eureka启动他们</p>
<p>2）改造config-client-eureka，为其增加amqp</p>
<p>pom增加amqp和actuator（提供刷新端点）； 配置中增加RabbitMQ的连接和用户信息</p>
<pre><code>spring.rabbitmq.host=localhost
spring.rabbitmq.port=5672
spring.rabbitmq.username=qx
spring.rabbitmq.password=123456
</code></pre><p>3)启动两个config-client-eureka，在不同的port上</p>
<p>4）试验：我们先访问config-client-eureka /from请求，可以看到获取到了配置信息<br>然后我们修改repo的配置，然后post请求/bus/refresh到config-client-eureka.<br>然后我们再访问两个客户端的/from ，将会看到修改后的配置文件</p>
<p><img src="https://raw.githubusercontent.com/wiki/zhuifengcc/zhuifengcc.github.io/images/Spring Cloud/Spring Cloud Bus/5-1.png" alt="架构图"></p>
<p>系统启动后，三个Service-A都会连接到Config-Server去获取配置。</p>
<p>如果我们修改Service-A的属性，我们需要向其中一个比如3实例发送/bus/refresh 的post请求。该请求会刷新到消息总线中，实例1，2也会获取到，从而实现动态更新。</p>
<p>局部刷新同样我们可以实现，通过/bus/refresh?destination=customers:9000，来指定刷新某个服务的配置</p>
<p><img src="https://raw.githubusercontent.com/wiki/zhuifengcc/zhuifengcc.github.io/images/Spring Cloud/Spring Cloud Bus/5-2.png" alt="架构优化"></p>
<p>上面的架构，服务配置更新需要指向某个实例，web hook配置写死了，如果以后进行服务器迁移，还不得不修改web hook的配置，所以需要调整。<br>在ConfigServer中引入SpringCloudBus，将其引入到消息总线中。 /bus/refresh请求直接post给ConfigServer就可以了。并通过/bus/refresh?destination=customers:9000的形式来指定更新配置</p>
<h2 id="kafaka-spring-cloud-bus"><a href="#kafaka-spring-cloud-bus" class="headerlink" title="kafaka + spring cloud bus"></a>kafaka + spring cloud bus</h2><p>pom需要引入spring-cloud-starter-bus-kafka 吧刚才的zookeeper+kafka启动起来，之前amqp整合中将破灭修改后，直接启动config-server和config-client</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/17/Spring Cloud：Spring Cloud Config/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhuifengcc">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沐奕">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/17/Spring Cloud：Spring Cloud Config/" itemprop="url">Spring Cloud: Spring Cloud Config</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-17T23:40:18+08:00">
                2018-08-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring-Cloud/" itemprop="url" rel="index">
                    <span itemprop="name">Spring Cloud</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Spring Cloud Config是用来为分布式系统中基础设施和微服务提供集中化外部配置的支持，分为客户端和服务端。<br>*客户端：微服务的各个微服务应用</p>
<pre><code>通过指定的配置中心来管理应用资源与业务的配置内容，启动时从配置中心获取加载配置信息
</code></pre><p>*服务端：分布式配置中心</p>
<pre><code>独立的微服务应用，连接配置仓库，为客户端获取配置信息。默认采用Git
</code></pre><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><p>构建一个Git分布式配置中心，并在客户端中通过配置中心获取配置</p>
<h3 id="配置中心构建"><a href="#配置中心构建" class="headerlink" title="配置中心构建"></a>配置中心构建</h3><p>1）springboot pom引入config-server即可<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">    xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.demo&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;config-server&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;name&gt;config-server&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">        &lt;spring-cloud.version&gt;Finchley.M9&lt;/spring-cloud.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencyManagement&gt;</span><br><span class="line">        &lt;dependencies&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;</span><br><span class="line">                &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">                &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">            &lt;/dependency&gt;</span><br><span class="line">        &lt;/dependencies&gt;</span><br><span class="line">    &lt;/dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line"></span><br><span class="line">    &lt;repositories&gt;</span><br><span class="line">        &lt;repository&gt;</span><br><span class="line">            &lt;id&gt;spring-milestones&lt;/id&gt;</span><br><span class="line">            &lt;name&gt;Spring Milestones&lt;/name&gt;</span><br><span class="line">            &lt;url&gt;https:<span class="comment">//repo.spring.io/milestone&lt;/url&gt;</span></span><br><span class="line">            &lt;snapshots&gt;</span><br><span class="line">                &lt;enabled&gt;false&lt;/enabled&gt;</span><br><span class="line">            &lt;/snapshots&gt;</span><br><span class="line">        &lt;/repository&gt;</span><br><span class="line">    &lt;/repositories&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="主类及配置"><a href="#主类及配置" class="headerlink" title="主类及配置"></a>主类及配置</h3><p>主类加入@EnableConfigServer、同时配置congfig中心<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=config-server</span><br><span class="line">server.port=<span class="number">7001</span></span><br><span class="line"></span><br><span class="line">spring.cloud.config.server.git.uri=https:<span class="comment">//github.com/zhuifengcc/SpringCloud-Learn/</span></span><br><span class="line">spring.cloud.config.server.git.searchPaths=config-repo</span><br><span class="line">spring.cloud.config.server.git.username=*****</span><br><span class="line">spring.cloud.config.server.git.password=*****</span><br></pre></td></tr></table></figure></p>
<p>然后我们在git上新建仓库SpringCloud-Learn，仓库下建立文件夹config-repo,文件夹下放入配置文件</p>
<p>*config.properties</p>
<pre><code>form=git-default-1.0
</code></pre><p>*config-dev.properties</p>
<pre><code>form=git-dev-1.0
</code></pre><p>*config-test.properties</p>
<pre><code>form=git-test-1.0
</code></pre><h3 id="启动应用看结果"><a href="#启动应用看结果" class="headerlink" title="启动应用看结果"></a>启动应用看结果</h3><p>可以通过如下几种方式获取配置信息，其中master为主分支名，如果有其它分支，只需要改为相应的分支名</p>
<p>/{application}/{profile}[/{label}]<br>/{application}-{profile}.properties<br>/{label}/{application}-{profile}.properties</p>
<p>上述url会映射{application}-{profile}.properties对应的配置文件，{label}对应Git上不同的分支，默认master，如访问<a href="http://localhost:7001/config/test" target="_blank" rel="noopener">http://localhost:7001/config/test</a></p>
<p>可以看到<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    name: <span class="string">"config"</span>,</span><br><span class="line">    profiles: [</span><br><span class="line">        <span class="string">"test"</span></span><br><span class="line">    ],</span><br><span class="line">    label: <span class="string">"master"</span>,</span><br><span class="line">    version: <span class="string">"03994b44d95897ae55dcf6f240e71c8d6e26c064"</span>,</span><br><span class="line">    state: <span class="keyword">null</span>,</span><br><span class="line">    propertySources: [</span><br><span class="line">        &#123;</span><br><span class="line">            name: <span class="string">"https://github.com/zhuifengcc/SpringCloud-Learn//config-repo/config-test.properties"</span>,</span><br><span class="line">            source: &#123;</span><br><span class="line">            from: <span class="string">"git-test-1.0"</span></span><br><span class="line">        &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            name: <span class="string">"https://github.com/zhuifengcc/SpringCloud-Learn//config-repo/config.properties"</span>,</span><br><span class="line">            source: &#123;</span><br><span class="line">            from: <span class="string">"git-default-1.0"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>config-server从Git获取后，会在本质相应地储存一份文件，实际上通过git clone命令复制了一个副本，然后返回给微服务进行加载。这样可以防止git崩坏掉无法获取配置。</p>
<h2 id="客户端配置映射"><a href="#客户端配置映射" class="headerlink" title="客户端配置映射"></a>客户端配置映射</h2><p>有了提供配置的配置中心，如何让客户端去获取配置</p>
<h3 id="新建spring-boot-项目"><a href="#新建spring-boot-项目" class="headerlink" title="新建spring boot 项目"></a>新建spring boot 项目</h3><p>命名为config-client，引入web和config-client</p>
<h3 id="新建测试类"><a href="#新建测试类" class="headerlink" title="新建测试类"></a>新建测试类</h3><p>建立common包，建立接口类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="comment">//可以使用@Value绑定配置服务中心的from属性</span></span><br><span class="line"><span class="comment">//也可以使用Environment获取配置属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Environment env;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/from"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">from</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> env.getProperty(<span class="string">"from"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;from&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String from;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/from2"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFrom</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"版本信息"</span>+from;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="bootstrap-properties-一定新建一个新的"><a href="#bootstrap-properties-一定新建一个新的" class="headerlink" title="bootstrap.properties 一定新建一个新的"></a>bootstrap.properties 一定新建一个新的</h3><pre><code>#spring.application.name必须为配置中的xx-aa.properties的xx，否则会value注入会报错。
spring.application.name=config
#spring.cloud.config.profile必须为配置中的xx-aa.properties的aa
spring.cloud.config.profile=test
spring.cloud.config.label=master
spring.cloud.config.uri=http://localhost:7001/

server.port=7002
</code></pre><h3 id="启动看结果"><a href="#启动看结果" class="headerlink" title="启动看结果"></a>启动看结果</h3><pre><code>http://localhost:7002/from2
版本信息git-test-1.0 
http://localhost:7002/from1
git-test-1.0
</code></pre><h3 id="服务端详细"><a href="#服务端详细" class="headerlink" title="服务端详细"></a>服务端详细</h3><h3 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h3><p><img src="https://raw.githubusercontent.com/wiki/zhuifengcc/zhuifengcc.github.io/images/Spring Cloud/Spring Cloud Config/4-1.png" alt="架构图"></p>
<p>包含如下几个要素：</p>
<p>远程Git仓库 Config Server<br>本地Git仓库：存放获取的Git配置本地<br>Server A、Server B<br>获取配置流程：</p>
<p>启动应用，根据bootstrap.properties中的{application应用名}、{profile环境名}、{label分支名}，向config Server发起请求 Config Server维护自己的Git仓库，查找相应配置信息，通过git clone下载到文件系统<br>Config Server创建ApplicationContext实例，从Git本地仓库加载配置文件，返回给用户端 客户端获取外部配置文件后加载到客户端的ApplicationContext实例中，优先加载外部，外部配置加载完毕后再加载本地配置</p>
<h3 id="Git仓库配置"><a href="#Git仓库配置" class="headerlink" title="Git仓库配置"></a>Git仓库配置</h3><p>Git的版本控制很好的与config服务进行融合，一个应用不同的部署实例可以轻松获取springcloudconfig的不同版本配置。<br>Git配置可以参照前面，同样也可以脱离Git比如；</p>
<pre><code>#使用本地仓库，脱离Git服务端，快速调试开发
spring.cloud.config.server.git.url=file://${user.home}/config-repo
</code></pre><h3 id="本地文件系统"><a href="#本地文件系统" class="headerlink" title="本地文件系统"></a>本地文件系统</h3><p>不使用Git，需要设置</p>
<pre><code>spring.profiles.active=native
</code></pre><p>Config server会默认从应用的src/main/resource下搜索配置文件。</p>
<h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>配置中心内容敏感，结合Spring Security可以实现<br>pom中引入security 在配置文件中指定用户名密码<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<pre><code>security.user.name=user
security.user.password=f4s8f1w9fs
</code></pre><p>启动config-server，可以访问<a href="http://localhost:7001/config/test/master" target="_blank" rel="noopener">http://localhost:7001/config/test/master</a></p>
<p>会跳转到登陆页面</p>
<p>*启动客户端，客户端访问不到配置中心的配置，启动时就会报错</p>
<pre><code>spring.cloud.config.username=user
spring.cloud.config.password=f4s8f1w9fs
</code></pre><p>做了用户名密码校验后可以</p>
<h3 id="高可用配置中心"><a href="#高可用配置中心" class="headerlink" title="高可用配置中心"></a>高可用配置中心</h3><p>有两种模式可以实现</p>
<p>传统模式：</p>
<p>多个config服务器，将指向同一个Git仓库，客户端通过config服务器的负载均衡器获取配置<br>服务模式：</p>
<p>将config作为微服务纳入eureka</p>
<h3 id="config-server改造"><a href="#config-server改造" class="headerlink" title="config server改造"></a>config server改造</h3><p>接下来，我们来看如何将config加入到eureka中<br>改造开始：</p>
<p>config server<br>pom增加eureka<br>application.properties配置添加</p>
<pre><code>eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/
</code></pre><p>主类添加@EnableDiscoveryClient 启动eureka和config server，可以看到注册上了</p>
<h3 id="client改造"><a href="#client改造" class="headerlink" title="client改造"></a>client改造</h3><p>pom引入eureka<br>bootstrap.properties中增加配置</p>
<pre><code>spring.application.name=config
server.port=7002

spring.cloud.config.discovery.enabled=true
spring.cloud.config.discovery.service-id=CONFIG-SERVER
spring.cloud.config.profile=test

eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/
</code></pre><p>主类添加@EnableDiscoveryClient 启动，按之前的访问/from、/from2接口，可以看到实现了</p>
<h3 id="动态刷新配置"><a href="#动态刷新配置" class="headerlink" title="动态刷新配置"></a>动态刷新配置</h3><p>spring cloud config可以实现实时更新配置，我们接着来改造。我们刚才启动的项目，访问/from<br>可以获取到</p>
<pre><code>git-test-1.0
</code></pre><p>修改配置后Git推送出去，发现访问/from还是没有发生变化。</p>
<p>需要修改配置。在clien端开启动态刷新</p>
<p>*client中新增actuator监控模块<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p>重启即可！</p>
<p>我们通过对client Post请求localhost:7002/refresh然后再访问可看到更新完成</p>
<p>改功能可以同Git仓库的WebHook进行关联，当Git提交变化时，就向相应的主机发送/refresh post请求。<br>问题来了，系统壮大后，维护配置刷新也会造成系统负担，而且容易犯错，如何解决复杂度？<br>我们需要SpringCloudBus来实现以消息总线的反思进行配置变更通知！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/07/Spring Cloud：Spring Cloud Zuul/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhuifengcc">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沐奕">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/07/Spring Cloud：Spring Cloud Zuul/" itemprop="url">Spring Cloud: Spring Cloud Zuul</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-07T23:13:58+08:00">
                2018-08-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring-Cloud/" itemprop="url" rel="index">
                    <span itemprop="name">Spring Cloud</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Zuul网关"><a href="#Zuul网关" class="headerlink" title="Zuul网关"></a>Zuul网关</h2><p>内部service通过服务注册发现相互调用，还有对外的OpenService，提供对外RESTful API服务，通过Nginx等进行负载均衡后提供给外部客户端。</p>
<p><img src="https://raw.githubusercontent.com/wiki/zhuifengcc/zhuifengcc.github.io/images/Spring Cloud/Spring Cloud Zuul/3-1.png" alt="基础架构图"></p>
<p>一、但是为了让路由正确分发，实例增减或ip变动等发生的情况，需要手动同步维护，系统规模大是，维护及其不便。<br>二、对外服务会有权限校验等机制，如用户登陆等，为了防止客户端发起请求时被篡改等，还会有签名校验机制。微服务将原本单一的应用拆成了多个应用，我们不得不在每个应用中去实现这样一套逻辑，这些校验代码非常冗余。一旦修改逻辑，需要将所有的应用上的逻辑进行修改。</p>
<p>所有我们需要API网关，所有外部客户端访问都需要经过它来进行过滤调度！</p>
<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>Zuul通过服务注册中心注册到Eureka，从而获取到服务实例。Zuul会默认通过以服务名作为ContextPath方式来创建映射。</p>
<p>对于签名校验，登陆等问题，完全可以做成独立的服务，从应用中剥离，在API网关服务上进行统一的调用来对服务接口做前置过滤。可以通过ZUul创建校验过滤器，指定哪些规则需要执行校验逻辑，通过校验才会被路由到具体的微服务接口，使得微服务更加专注于业务逻辑开发。</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><p>我们来新建一个Zuul。</p>
<p>1.pom<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">    xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">&lt;groupId&gt;com.demo&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;api-gateway&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">&lt;name&gt;api-gateway&lt;/name&gt;</span><br><span class="line">&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.0.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">    &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">    &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">    &lt;spring-cloud.version&gt;Finchley.M9&lt;/spring-cloud.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.4.4.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-netflix-eureka-server&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.0.0.M6&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">            &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br><span class="line"></span><br><span class="line">&lt;repositories&gt;</span><br><span class="line">    &lt;repository&gt;</span><br><span class="line">        &lt;id&gt;spring-milestones&lt;/id&gt;</span><br><span class="line">        &lt;name&gt;Spring Milestones&lt;/name&gt;</span><br><span class="line">        &lt;url&gt;https:<span class="comment">//repo.spring.io/milestone&lt;/url&gt;</span></span><br><span class="line">        &lt;snapshots&gt;</span><br><span class="line">            &lt;enabled&gt;false&lt;/enabled&gt;</span><br><span class="line">        &lt;/snapshots&gt;</span><br><span class="line">    &lt;/repository&gt;</span><br><span class="line">&lt;/repositories&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></p>
<p>2.主类增加@EnableZuulProxy<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="meta">@SpringCloudApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiGatewayApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(ApiGatewayApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.配置</p>
<pre><code>spring.application.name=api-gateway
server.port=5555
#服务实例映射
zuul.routes.api-a-url.path=/api-a/**
#传统路由方式，维护成本高
#zuul.routes.api-a-url.url=http://localhost:8080/ 
#面向服务的路由方式
zuul.routes.api-a.serviceId=HELLO-SERVER
zuul.routes.api-b-url.path=/api-b/**
zuul.routes.api-b.serviceId=FEIGN-CONSUMER
#zuul注册到eureka
eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka
</code></pre><p>然后我们启动eureka注册中心、hello-server、feign-consumer、还有api-gateway<br>已经配置了路由规则。我们访问api的<a href="http://localhost:5555/api-b/feign-consumer" target="_blank" rel="noopener">http://localhost:5555/api-b/feign-consumer</a> .api网关吧请求转发到相应的服务实例上去，只需配置简单的path和serviceId映射组合即可。</p>
<p>ps: 若出现不能正常路由到相应服务的情况，考虑是否超时，添加配置</p>
<pre><code>zuul.host.socket-timeout-millis=60000
zuul.host.connect-timeout-millis=10000
hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=60000
</code></pre><h2 id="请求过滤"><a href="#请求过滤" class="headerlink" title="请求过滤"></a>请求过滤</h2><p>实现请求路由的基本功能后，微服务可以通过统一的API网关作为入口进行访问。但是访问权限等没有限制，任何请求都会被转发，最简单粗暴的是在所有微服务上添加一套权限逻辑，但是不可取。我们需要剥离，形成一个独立的鉴权服务。而Zuul的一个核心功能就是：请求过滤，只需要继承ZuulFilter抽象类并实现4个抽象函数即可完成请求的拦截与过滤。来看一个简单的Zuul过滤器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger log=LoggerFactory.getLogger(AccessFilter.class);</span><br><span class="line">    <span class="comment">//过滤器类型，决定过滤器在什么生命周期中执行，pre代表在请求路由之前进行。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"pre"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//过滤器执行顺序</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//过滤器是否要被执行，可以制定该函数的过滤器有效范围</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//过滤器逻辑类型，context.setSendZuulResponse(false)命令Zuul过滤该请求，</span></span><br><span class="line">    <span class="comment">//context.setResponseStatusCode(401)返回错误代码</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        RequestContext context = RequestContext.getCurrentContext();</span><br><span class="line">        HttpServletRequest requset = context.getRequset();</span><br><span class="line">        log.info(<span class="string">"send &#123;&#125; request to &#123;&#125;"</span>, requset.getMethod(), requset.getRequsetURL().toString());</span><br><span class="line"></span><br><span class="line">        Obeject accessToken = requset.getParamter(<span class="string">"accessToken"</span>);</span><br><span class="line">        <span class="keyword">if</span>(accessToken == <span class="keyword">null</span>)&#123;</span><br><span class="line">            log.warn(<span class="string">"token empty!!"</span>);</span><br><span class="line">            context.setSendZuulResponse(<span class="keyword">false</span>);</span><br><span class="line">            context.setResponseStatusCode(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">"access token ok!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实现过滤器后，不会直接生效，需要创建具体的bean才能启动<br>在主类中增加如下方法才会生效<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> AccessFilter accessFilter（）&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AccessFilter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们测试</p>
<pre><code>http://localhost:5555/api-a/index
http://localhost:5555/api-a/index&amp;accessToken=token
</code></pre><h2 id="路由详解"><a href="#路由详解" class="headerlink" title="路由详解"></a>路由详解</h2><h3 id="路由的一些基本配置"><a href="#路由的一些基本配置" class="headerlink" title="路由的一些基本配置"></a>路由的一些基本配置</h3><p>回顾一下路由配置</p>
<pre><code>zuul.routes.api-a-url.path=/api-a/**
zuul.routes.api-a.serviceId=HELLO-SERVER
zuul.routes.api-b-url.path=/api-b/**
zuul.routes.api-b.serviceId=FEIGN-CONSUMER
</code></pre><p>除了path与serviceId的映射外，还有更简洁的配置</p>
<pre><code>#zuul.routes.&lt;serviceId&gt;=&lt;path&gt;
zuul.routes.user-service=/user-service/**
#将zuul看作eureka下的一个服务，他会获取所有实例清单，自己就得到了serviceID与服务实例地址的映射，api网关可自动找到最佳匹配
</code></pre><p>虽然eureka与zuul省去了维护服务配置的工作，但是实际情况一般如下</p>
<pre><code>zuul.routes.fegin-consumer.path=/fegin-consumer/**
zuul.routes.fegin-consumer.serviceId=fegin-consumer
</code></pre><p>zuul的默认规则可以完全不需要我们这样一个一个配置。<br>当我们为API网关引入eureka后，每个服务都会创建一个默认的路由规则，path使用serviceId配置的服务名作为请求前缀。<br>由于默认情况eureka的所有服务都会被zuul自动创建映射，而有些我们不希望暴露出去，可以用</p>
<pre><code>zuul.ignore-serices=*
zuul.routes.hello-server.serviceId=hello-server
</code></pre><p>如上设置一个服务名匹配表达式来定义不自动映射，只需要添加我们想要暴露的服务hello-server，而fegin-consumer则不会暴露出去</p>
<h3 id="自定义路由规则"><a href="#自定义路由规则" class="headerlink" title="自定义路由规则"></a>自定义路由规则</h3><p>构建微服务时，为了兼容不同外部版本，一般会采用开闭原则进行设计开发。我们可以根据服务版本表示来知道，如下<br>userservice-v1、userservice-v2、orderservice-v1、orderservice-v2 </p>
<p>这样，路由默认会映射成/userservice-v1、/userservice-v2<br>但是这样不利于通过规则进行管理，可以改成如下这样</p>
<pre><code>/v1/userservice
//PatternServiceRouteMapper添加到主类下，通过正则表达式定义路由映射
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PatternServiceRouteMapper <span class="title">serviceRouteMapper</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PatternServiceRouteMapper(</span><br><span class="line">        <span class="string">"(?&lt;name&gt;^.+)-(?&lt;version&gt;v.+$)"</span>,</span><br><span class="line">        <span class="string">"$&#123;version&#125;/$&#123;name&#125;"</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="路径匹配"><a href="#路径匹配" class="headerlink" title="路径匹配"></a>路径匹配</h3><p>可以通过如下来看</p>
<pre><code>/user-service/?     匹配一个/user-service/a、/user-service/d、/user-service/3
/user-service/*     匹配任意/user-service/afdsfs
/user-service/**    匹配任意及多级目录 /user-service/afdsfs、/user-service/afdsfs/zz
</code></pre><h2 id="Hystrix和Ribbon支持"><a href="#Hystrix和Ribbon支持" class="headerlink" title="Hystrix和Ribbon支持"></a>Hystrix和Ribbon支持</h2><p>Zuul的依赖包含了Hystrix和Ribbon的依赖，所以Zuul拥有线程隔离和断路器的自我保护功能，以及对服务调用的客户端负载均衡。<br>ps: 使用path与url的映射关系来配置路由规则的时候，路由转发的请求不会采用HystrixCommand包装，故不含有上述所说的Hystrix和Ribbon的特性，故尽量使用path和serviceId的组合来配置</p>
<h2 id="Zuul过滤器！"><a href="#Zuul过滤器！" class="headerlink" title="Zuul过滤器！"></a>Zuul过滤器！</h2><p>zuul包含对请求路由及过滤两个功能，路由将外部请求转发到微服务实例，过滤将请求进行校验，实现请求校验服务聚合等功能</p>
<p>spring cloud zuul包含4个基本特性实际上ZuulFilter中4个抽象方法：</p>
<h3 id="过滤类型-String-filterType"><a href="#过滤类型-String-filterType" class="headerlink" title="过滤类型 String filterType()"></a>过滤类型 String filterType()</h3><p>需要返回一个字符串代表过滤器类型，Zuul默认了4个不同的生命周期过滤类型。</p>
<pre><code>pre：路由请求前调用
routing：请求时调用
post：routing和error过滤器之后调用
error：处理请求时发生错误被调用   
</code></pre><p>filterType4种过滤器类型定义了一个外部HTTP到达API网关，直到返回请求结果的全部生命周期。可以通过下图清晰的看出来流转过程<br><img src="https://raw.githubusercontent.com/wiki/zhuifengcc/zhuifengcc.github.io/images/Spring Cloud/Spring Cloud Zuul/3-2.png" alt="过滤器流转图"></p>
<p>这其中为了让API网关可以更方便使用，默认实现类一批核心的过滤器。定义在springcloud core下的netflix.zuul.filters。</p>
<p><img src="https://raw.githubusercontent.com/wiki/zhuifengcc/zhuifengcc.github.io/images/Spring Cloud/Spring Cloud Zuul/3-3.png" alt="过滤器下包结构"></p>
<h3 id="顺序执行-int-filterOrder"><a href="#顺序执行-int-filterOrder" class="headerlink" title="顺序执行 int filterOrder()"></a>顺序执行 int filterOrder()</h3><pre><code>用值越小优先级越高
</code></pre><h3 id="执行条件-boolean-shouldFilter"><a href="#执行条件-boolean-shouldFilter" class="headerlink" title="执行条件 boolean shouldFilter()"></a>执行条件 boolean shouldFilter()</h3><pre><code>是否执行该过滤器
</code></pre><h3 id="具体操作-Object-run"><a href="#具体操作-Object-run" class="headerlink" title="具体操作 Object run()"></a>具体操作 Object run()</h3><pre><code>自定义过滤逻辑，是否要拦截当前请求
</code></pre><h3 id="过滤器生命周期表"><a href="#过滤器生命周期表" class="headerlink" title="过滤器生命周期表"></a>过滤器生命周期表</h3><p><img src="https://raw.githubusercontent.com/wiki/zhuifengcc/zhuifengcc.github.io/images/Spring Cloud/Spring Cloud Zuul/3-4.png" alt="过滤器生命周期表"></p>
<h2 id="Zuul异常处理"><a href="#Zuul异常处理" class="headerlink" title="Zuul异常处理"></a>Zuul异常处理</h2><h3 id="error阶段直接抛出异常"><a href="#error阶段直接抛出异常" class="headerlink" title="error阶段直接抛出异常"></a>error阶段直接抛出异常</h3><p>可以看到，核心过滤器并没有实现error阶段，自己实现一个异常过滤器来看看怎么处理</p>
<p>1.创建一个pre类型过滤器，在过滤器中抛出一个异常。在api-gateway服务中建立filter包<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowExceptionFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger log= LoggerFactory.getLogger(ThrowExceptionFilter.class);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"pre"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"pre filter, throw RuntimeException"</span>);</span><br><span class="line">        doSomething();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"errors"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们运行注册中心、hello-server、api网关，利用<a href="http://localhost:5555/api-a/hello" target="_blank" rel="noopener">http://localhost:5555/api-a/hello</a> 访问，可以看到报错，api服务控制台输出了错误.</p>
<pre><code>Whitelabel Error Page
This application has no explicit mapping for /error, so you are seeing this as a fallback.

Mon Apr 16 15:53:24 CST 2018
There was an unexpected error (type=Internal Server Error, status=500).
pre:ThrowExceptionFilter
</code></pre><p>我们看一下RibbonRoutingFilter下的run如何抛出异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RequestContext context = RequestContext.getCurrentContext();</span><br><span class="line">        <span class="keyword">this</span>.helper.addIgnoredHeaders(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            RibbonCommandContext commandContext = <span class="keyword">this</span>.buildCommandContext(context);</span><br><span class="line">            ClientHttpResponse response = <span class="keyword">this</span>.forward(commandContext);</span><br><span class="line">            <span class="keyword">this</span>.setResponse(response);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ZuulException var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ZuulRuntimeException(var4);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ZuulRuntimeException(var5);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们相应的改写下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"即将抛出错误"</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            doSomething();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ZuulRuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到</p>
<pre><code>Whitelabel Error Page
This application has no explicit mapping for /error, so you are seeing this as a fallback.

Mon Apr 16 15:56:20 CST 2018
There was an unexpected error (type=Internal Server Error, status=500).
MY errors!!!!!!
</code></pre><h3 id="禁用过滤器"><a href="#禁用过滤器" class="headerlink" title="禁用过滤器"></a>禁用过滤器</h3><p>无论是核心过滤器还是自定义的过滤器，只要在Api网关中创建了实例，那么默认情况都是启用状态的。如果不想使用了，该如何禁用过滤器</p>
<p>1.可以重写sholdFliter逻辑返回false，但是这样会修改代码重新编译</p>
<p>2.特定参数过滤</p>
<pre><code>zuul.&lt;SimpleClassName&gt;.&lt;filterType&gt;.disable=true
</code></pre><p>其中是过滤器名称过滤器类型。如</p>
<pre><code>zuul.AccessFilter.pre.disable=true
</code></pre><p>不仅可以过滤自定义的，核心过滤器也可以过滤。可以将Springcloud的过滤器全部抛弃并实现一套自己的过滤器处理机制。</p>
<h2 id="Zuul动态加载路由及过滤器"><a href="#Zuul动态加载路由及过滤器" class="headerlink" title="Zuul动态加载路由及过滤器"></a>Zuul动态加载路由及过滤器</h2><p>API网关可是对外提供服务的入口，7X24小时服务系统，不可能重启及关闭应用，因此必须具备动态更新内部逻辑的能力，比如动态添加删除过滤器、动态修改路由规则</p>
<h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><p>只需要利用config的动态刷新机制，从Git获取配置，轻松实现路由规则的动态刷新，</p>
<p>启动eureka，启动配置中心config，config注册到eureka并从Git中获取配置，接下来需要Zuul网关，网关从config获取配置<br>1首先我们在Git上发布我们的配置api-gateway.properties</p>
<pre><code>zuul.routes.service-a.path=/service-a/**
zuul.routes.service-a.serviceId=hello-server
zuul.routes.service-b.path=/service-b/**
zuul.routes.service-b.url=http://www.baidu.com  
</code></pre><p>2建立api-gateway-dynamic-route，从config-server中获取配置</p>
<p>3pom中引入zuul、eureka、config依赖</p>
<p>4bootstrap.properties配置</p>
<pre><code>spring.application.name=api-gateway
server.port=5556
spring.cloud.config.uri=http://localhost:7001/
eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/
</code></pre><p>5主类添加一个动态刷新RefreshScope<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiGatewayDynamicRouteApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ApiGatewayDynamicRouteApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RefreshScope</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(<span class="string">"zuul"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ZuulProperties <span class="title">zuulProperties</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ZuulProperties();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>6启动api-gateway 还有helloserver</p>
<p>我们通过访问api-gateway<br><a href="http://localhost:5556/service-a/hello" target="_blank" rel="noopener">http://localhost:5556/service-a/hello</a> 跳转到了hello server的服务</p>
<p><a href="http://localhost:5556/service-b" target="_blank" rel="noopener">http://localhost:5556/service-b</a> 跳转到了百度<br>路由实现</p>
<h3 id="动态过滤器"><a href="#动态过滤器" class="headerlink" title="动态过滤器"></a>动态过滤器</h3><p>过滤请求的动态加载也可以通过类似的方式实现,但有所不同，路由规则是配置，请求过滤是编码实现。<br>所以对于请求过滤去的动态加载，需要借助基于JVM实现的动态语言才行，比如Groovy</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/02/Spring Cloud：Spring Cloud Feign/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhuifengcc">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沐奕">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/02/Spring Cloud：Spring Cloud Feign/" itemprop="url">Spring Cloud: Spring Cloud Feign</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-02T23:05:22+08:00">
                2018-08-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring-Cloud/" itemprop="url" rel="index">
                    <span itemprop="name">Spring Cloud</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Feign声明式服务调用"><a href="#Feign声明式服务调用" class="headerlink" title="Feign声明式服务调用"></a>Feign声明式服务调用</h2><p>在实践过程中，我们发现对于Ribbon和Hystrix的使用几乎是同时出现的，是否有更深层次的封装简化开发呢？Feign整合了Ribbon和Hystrix，还提供了声明式的web客户端定义方式。</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><p>1.pom<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p>2.main添加<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br></pre></td></tr></table></figure></p>
<p>3.controller<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloService helloService;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/fegin-consumer"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloConsumer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helloService.index();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4.service<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(<span class="string">"hello-service"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/index"</span>)</span><br><span class="line">    <span class="function">String <span class="title">index</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>5.properties<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=feign-consumer</span><br><span class="line">server.port=<span class="number">9001</span></span><br><span class="line">eureka.client.serviceUrl.defaultZone=http:<span class="comment">//localhost:1111/eureka/</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到consumer没有通过restTemplate，直接同服务名@FeignClient(“hello-service”)通过<a href="http://localhost:9001/feign-consumer" target="_blank" rel="noopener">http://localhost:9001/feign-consumer</a> ,通过接口的方式访问了hello-service服务提供者，这是一个不带参数的REST服务绑定。</p>
<p><img src="https://raw.githubusercontent.com/wiki/zhuifengcc/zhuifengcc.github.io/images/Spring Cloud/Spring Cloud Feign/1-1.png" alt="调用效果展示"></p>
<h2 id="不同的参数绑定方法"><a href="#不同的参数绑定方法" class="headerlink" title="不同的参数绑定方法"></a>不同的参数绑定方法</h2><p>实际业务接口复杂得多，HTTP各个位置需要传入不同类型的参数，返回也可能是一个复杂的对象。首先，我们扩展一下客户端的服务提供者<br>1.添加User pojo，包含name，age，及空构造！</p>
<p>2.改造controller接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello Eureka"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/hello1/&#123;name&#125;"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@PathVariable String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello Eureka "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/hello2"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">hello</span><span class="params">(@RequestHeader String name, @RequestHeader Integer age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/hello3"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@RequestBody User user)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span> + user.getName() + <span class="string">","</span> + user.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>开始对feign consumer绑定请求，首先添加User类。feign采用的类似mvc的语法，但不是完全一样，比如MVC中，注解会根据参数名来作为默认值，但是Feign中绑定的参数必须通过value属性来指明参数名。不然会抛出IllegalStateException异常，value属性不能为空。</p>
<p>1.改造service</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(<span class="string">"hello-server"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(“/hello”)</span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/hello1/&#123;name&#125;"</span>,method = RequestMethod.GET)</span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(@PathVariable(<span class="string">"name"</span>)</span> String name)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/hello2"</span>,method = RequestMethod.GET)</span><br><span class="line">    <span class="function">User <span class="title">hello</span><span class="params">(@RequestHeader(<span class="string">"name"</span>)</span> String name, @<span class="title">RequestHeader</span><span class="params">(<span class="string">"age"</span>)</span> Integer age)</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/hello3"</span>,method = RequestMethod.POST)</span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(@RequestBody User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.改造controller</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloService helloService;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/fegin-consumer"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloConsumer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helloService.hello();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/fegin-consumer2"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloConsumer2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(helloService.hello()).append(<span class="string">"\n"</span>);</span><br><span class="line">        sb.append(helloService.hello(<span class="string">"zhuifengcc"</span>)).append(<span class="string">"\n"</span>);</span><br><span class="line">        sb.append(helloService.hello(<span class="string">"zhuifengcc"</span>,<span class="number">24</span>)).append(<span class="string">"\n"</span>);</span><br><span class="line">        sb.append(helloService.hello(<span class="keyword">new</span> User(<span class="string">"qx"</span>,<span class="number">24</span>))).append(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试！<br>启动注册中心，启动服务提供者，启动fegin。</p>
<h2 id="如何在Feign中使用Ribbon"><a href="#如何在Feign中使用Ribbon" class="headerlink" title="如何在Feign中使用Ribbon"></a>如何在Feign中使用Ribbon</h2><p>全局设置，如修改默认的客户端调用超时时间</p>
<pre><code>ribbon.ConnectTimeout=500
ribbon.ReadTimeout=5000
</code></pre><p>指定服务配置</p>
<p>针对实际服务的特性进行调整，实际上通过@FeignClient声明Feign客户端的同时，也创建了一个Ribbon客户端，名为HELLO-SERVICE。可通过如下方式进行具体配置</p>
<pre><code>HELLO-SERVICE.ribbon.ConnectTimeout = 500
HELLO-SERVICE.ribbon.ReadTimeout = 2000
...
</code></pre><p>重试机制</p>
<p>在Spring Cloud Feign中默认实现了请求的重试机制，可参照Ribbon章节。</p>
<p>ps: Ribbon的超时与Hystrix的超时是两个概念，一般需要Hystrix的超时时间大于Ribbon的超时时间，否则触发服务降级，负载的超时就无意义了！</p>
<h2 id="如何在Feign中使用Hystrix"><a href="#如何在Feign中使用Hystrix" class="headerlink" title="如何在Feign中使用Hystrix"></a>如何在Feign中使用Hystrix</h2><p>默认情况下会将所有方法封装到Hystrix中进行保护</p>
<p>全局设置，如修改全局超时时间</p>
<pre><code>Hystrix.command.default.execution.isolation.thread.timeoutInMillseconds = 5000
</code></pre><p>关闭Feign客户端的Hystrix支持</p>
<pre><code>feign.hystrix.enabled = false
</code></pre><h2 id="服务降级配置"><a href="#服务降级配置" class="headerlink" title="服务降级配置"></a>服务降级配置</h2><p>Feign下服务降级逻辑的实现只需要为Feign客户端的定义接口编写一个具体的接口实现类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceFallback</span> <span class="keyword">implements</span> <span class="title">HelloService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@RequestParam(<span class="string">"name"</span>)</span> String name)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">hello</span><span class="params">(@RequestHeader(<span class="string">"name"</span>)</span> String name, @<span class="title">RequestHeader</span><span class="params">(<span class="string">"age"</span>)</span> Integer age)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">"unknown"</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">Hello</span><span class="params">(@RequestBody User user)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>并在服务接口声明中添加fallback指向<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(name=<span class="string">"HELLO-SERVICE"</span>, fallback = HelloServiceFallback.class)</span><br></pre></td></tr></table></figure></p>
<h2 id="Feign日志配置"><a href="#Feign日志配置" class="headerlink" title="Feign日志配置"></a>Feign日志配置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">logging.level.com.cg.service.HelloService=DEBUG</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignApplication</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Logger.<span class="function">Level <span class="title">feginLoggerLevel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(FeignApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/02/Spring Cloud：Spring Cloud Hystrix/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhuifengcc">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沐奕">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/02/Spring Cloud：Spring Cloud Hystrix/" itemprop="url">Spring Cloud: Spring Cloud Hystrix</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-02T17:29:23+08:00">
                2018-07-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring-Cloud/" itemprop="url" rel="index">
                    <span itemprop="name">Spring Cloud</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="服务容错保护"><a href="#服务容错保护" class="headerlink" title="服务容错保护"></a>服务容错保护</h2><p>在微服务架构中，我们将系统拆分成了很多服务单元，各单元的应用间通过服务注册与订阅的方式互相依赖，由于每个单元都在不同的进程中运行，依赖通过远程调用的方式执行，这样就有可能因为网络原因或者依赖服务自身问题出现调用故障或者延迟，会直接导致调用方的对外服务也出现延迟，若此时调用方的请求不断增加，最后就会因为等待出现故障方响应形成任务积压，最终导致自身服务的瘫痪。为了解决这样的问题，产生了断路器等一系列的服务保护机制。</p>
<p>在分布式架构中，当某个服务发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个错误响应，而不是长时间的等待。这样不会使得线程因故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延。</p>
<p>Spring Cloud Hystirx实现了断路器、线程隔离等一系列服务保护功能。基于Netflix的开源框架Hystirx实现的，该框架的目标在于通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystirx具备服务降级、服务熔断、线程和信号隔离、请求缓存、请求合并以及服务监控等强大功能。</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><p>我们模拟一个服务调用关系：</p>
<p><img src="https://raw.githubusercontent.com/wiki/zhuifengcc/zhuifengcc.github.io/images/Spring Cloud/Spring Cloud Hystrix/2-1.png" alt="快速入门"></p>
<p>若此时关闭其中一个服务实例，发送Get请求到消费者<a href="http://localhost:9000/ribbon-consumer" target="_blank" rel="noopener">http://localhost:9000/ribbon-consumer</a> 当轮询到不可用的服务实例的时候，不会输出正常的Hello</p>
<p>我们再看看引入Spring Cloud Hystrix之后的情形，在maven中引入Spring-cloud-starter-hystrix依赖：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p>随后我们在consumer的主类上通过使用注解@EnableCircuitBreaker开启断路器功能：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@LoadBalanced</span></span><br><span class="line">	<span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ps:这里也可以直接使用注解@SpringCloudApplication，查看源码可以看到是包含@SpringBootApplication、@EnableDiscoveryClient、@EnableCircuitBreaker，so一个标准的SpringCloud应用应包含服务发现和断路器。</p>
<p>改造服务消费方式，在Service中新建方法调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"helloFallBack"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForEntity(<span class="string">"http://HELLO-SERVICE/hello"</span>,String.class).getBody();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloFallBack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>引入依赖，使用注解@HystrixCommand进行服务降级：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.netflix.hystrix&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hystrix-javanica&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p>改造controller：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloService helloService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/ribbon-consumer"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">HelloConsumer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helloService.helloService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>重启服务消费者对服务进行消费，当我们设定的2个服务提供者实例正常时，访问<a href="http://localhost:9000/ribbon-consumer" target="_blank" rel="noopener">http://localhost:9000/ribbon-consumer</a> 可以看到正常的Hello输出信息。同理，关闭一个端口的服务实例（或者设定一定的超时时间），当轮询到不可用的服务时，我们可以看到我们处理的服务回滚生效，返回了输出的Error信息<br><img src="https://raw.githubusercontent.com/wiki/zhuifengcc/zhuifengcc.github.io/images/Spring Cloud/Spring Cloud Hystrix/2-2.png" alt="Hystrix做了服务回滚"></p>
<p>ps：Hystrix默认的超时时间为2000ms</p>
<h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>Hystrix使用了命令模式和RxJava（RxJava的观察者-订阅者模式）</p>
<p>命令模式：将客户端的请求封装为一个对象，可使用不同请求对客户端进行参数化。实现行为请求者与行为实现者解耦。<br>简单说，原来是客户端直接调用业务逻辑方法，但是这两个方法有耦合。为了解耦，设计一个中间的命令方法，命令方法接受业务方法bean对象。客户端调用命令方法的excute，命令方法再执行业务代码。</p>
<p>eg:</p>
<p>1.接收者（操作者）：被调用的业务代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reciver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//真正的业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.Command接口及实现—（通过command实现了解耦）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">excute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Reciver reciver;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteCommand</span><span class="params">(Reciver reciver)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.reciver=reciver;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">excute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        reciver.action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.调用者Invoker:持有一个命令对象，并且可以在需要的时候通过命令对象完成具体的业务逻辑<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Invoker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Command command;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommond</span><span class="params">(Command command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>&#123;</span><br><span class="line">        command.excute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4.使用命令模式。可以诸多多个命令模式。比如新建文件、复制文件、删除文件，只需再需要时直接调用即可<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Reciever reciever = <span class="keyword">new</span> Reciever();</span><br><span class="line">        Command command = <span class="keyword">new</span> ConceretCommand(reciever);</span><br><span class="line">        Invoker invoker = <span class="keyword">new</span> Invoker();</span><br><span class="line">        invoker.serCommond(commond);</span><br><span class="line">        invoker.action()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>RxJava的观察者-订阅者模式：</p>
<pre><code>a) Observable向订阅者Subsciber发布事件，Subsciber接受到后进行处理。事件通常就是对依赖服务的调用
b) Observable可以发出多个事件，直到结束或者发生异常
c) Observable每发送一个事件，就要调用Subsciber的onNext()方法
d) 每一个Observable执行，最后一定会通过Subsciber的onCompleted或者onError结束操作流
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> rx.Observable;</span><br><span class="line"><span class="keyword">import</span> rx.Subscriber;</span><br><span class="line"><span class="comment">//事件源observable</span></span><br><span class="line">Observable&lt;String&gt; observable = Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</span><br><span class="line">        subscriber.onNext(<span class="string">"Hello RxJava"</span>);</span><br><span class="line">        subscriber.onNext(<span class="string">"I am a programmer"</span>);</span><br><span class="line">        subscriber.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//订阅者Subsciber</span></span><br><span class="line">Subscriber&lt;String&gt; subscriber=<span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Subscriber: "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//发布者触发事件发布</span></span><br><span class="line">observable.subscribe(subscriber);</span><br></pre></td></tr></table></figure>
<p>这里对相关东西做简单列举：</p>
<pre><code>HystrixCommand: 用在依赖的服务返回单个操作结果的时候
HystrixObservableCommand: 用在依赖的服务返回多个服务结果的时候
</code></pre><p>执行方式：</p>
<pre><code>HystrixCommand：
    execute(): 同步执行，从依赖的服务返回一个单一的结果对象，或是在发生错误的时候抛出异常。
    queue(): 异步执行，直接返回一个Future对象，其中包含了服务执行结束时要返回的单一结果对象。
HystrixObservableCommand：
    observe(): 返回Observable对象，它代表了操作的多个结果，它是一个Hot Obsevable（不论“事件源”是否有“订阅者”，都会在创建后对事件进行发布，所以对于它的每一个“订阅者”都是可能是从“事件源”的中途开始的，并可能只是看到了整个过程的局部）
    toObservavble():同样也会返回Observable对象，也代表了操作的多个结果，但塔返回的是一个Cold Obsevable（在没有“订阅者”的时候不会发布事件，而是进行等待，直到有“订阅者”之后才发布事件，可以保证从一开始看到整个操作的过程）
</code></pre><p>工作流程：</p>
<pre><code>1.创建HystrixCommand或HystrixObservableCommand对象（命令模式）

2.命令执行（上述执行方式的执行）

3.结果是否被缓存（命令缓存命中，结果立即以Observable对象形式返回）

4.断路器是否打开（关闭，转5步；开启fallback）

5.线程池/请求队列/信号量是否占满（资源占满，开启fallback）

6.HystrixObservableCommand.run或HystrixCommand.run

7.计算断路器的健康度

8.fallback处理（4,5,6步会跳至）

9.返回成功的响应
</code></pre><h2 id="依赖隔离"><a href="#依赖隔离" class="headerlink" title="依赖隔离"></a>依赖隔离</h2><p>同Docker线程隔离类似，Hystrix使用“舱壁”模式实现线程池的隔离，他会为每一个依赖服务创建一个独立的线程池，某个依赖服务延迟过高，不会拖慢其他的依赖服务</p>
<p>例如调用产品服务的Command放入A线程池, 调用账户服务的Command放入B线程池. 这样做的主要优点是运行环境被隔离开了. 这样就算调用服务的代码存在bug或者由于其他原因导致自己所在线程池被耗尽时, 不会对系统的其他服务造成影响. 但是带来的代价就是维护多个线程池会对系统带来额外的性能开销. 如果是对性能有严格要求而且确信自己调用服务的客户端代码不会出问题的话, 可以使用Hystrix的信号模式(Semaphores)来隔离资源。</p>
<h2 id="Hystrix详解"><a href="#Hystrix详解" class="headerlink" title="Hystrix详解"></a>Hystrix详解</h2><h3 id="创建请求命令"><a href="#创建请求命令" class="headerlink" title="创建请求命令"></a>创建请求命令</h3><p>我们也可以通过继承的方式实现对依赖服务的调用过程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">User</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserCommand</span><span class="params">(Setter setter, RestTemplate restTemplate, Long id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(setter);</span><br><span class="line">        <span class="keyword">this</span>.restTemplate = restTemplate;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> User <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://USER-SERVICE/user/&#123;1&#125;"</span>,User.class, id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同步执行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User u = <span class="keyword">new</span> UserCommand(restRemple, <span class="number">1L</span>).execute();</span><br></pre></td></tr></table></figure></p>
<p>异步执行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回的对象调用get方法获取结果</span></span><br><span class="line">Future&lt;User&gt; futureUser = <span class="keyword">new</span> UserCommand(restRemple, <span class="number">1L</span>).queue();</span><br></pre></td></tr></table></figure></p>
<p>使用注解的方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同步的方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line">    <span class="meta">@HystrixCommand</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(String uid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://USER_SERVICE/users/&#123;1&#125;"</span>,User.class,id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//异步的方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line">    <span class="meta">@HystrixCommand</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Future&lt;User&gt; <span class="title">getUserById</span><span class="params">(String uid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AsyncResult&lt;User&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> User <span class="title">invoke</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://USER_SERVICE/users/&#123;1&#125;"</span>,User.class,id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="定义服务降级"><a href="#定义服务降级" class="headerlink" title="定义服务降级"></a>定义服务降级</h3><p>fallback是Hystrix命令执行失败时使用的后备方法，用来实现服务的降级处理逻辑。<br>代码实现方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">User</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserCommand</span><span class="params">(Setter setter, RestTemplate restTemplate, Long id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(setter);</span><br><span class="line">        <span class="keyword">this</span>.restTemplate = restTemplate;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> User <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://USER-SERVICE/user/&#123;1&#125;"</span>,User.class, id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> User <span class="title">getFallback</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="function">reuturn new <span class="title">User</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>异常传播：</p>
<p>在HystrixCommand实现的run方法抛出异常的时候，除了HystrixBadRequestException之外，其他异常均会被认为执行失败并触发服务降级</p>
<p>可使用以下的方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand</span>(ignoreExceptions = &#123;BadRequestException.class&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(Long id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://USER-SERVICE/users/&#123;1&#125;"</span>, User.class, id);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>当方法抛出BadRequestException，相当于被ignore，此异常会被包装在HystrixBadRequestException中抛出，不会出发服务降级。</p>
<p>异常获取：</p>
<p>当Hystrix进入服务降级之后，需要针对不同的异常进行针对性的处理，如何获取当前抛出的异常？</p>
<p>传统继承方式中，可以用getFallback()方法通过Throwable getExecutionException()方法来获取具体异常</p>
<p>注解方式中，在fallback实现方法的参数中增加Throwable e 对象的定义<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"fallback"</span>)</span><br><span class="line"><span class="function">User <span class="title">getUserById</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"getUserById command failed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">User <span class="title">fallback</span><span class="params">(String id, Throwable e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> <span class="string">"getUserById command failed"</span>.equals(e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="线程池划分"><a href="#线程池划分" class="headerlink" title="线程池划分"></a>线程池划分</h3><p>Hystrix命令默认的线程池划分是根据命令组来实现的。Hystrix可以设置相应的命令名称、命令组及HystrixTheadPoolKey来对线程池进行更灵活的划分<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand</span>(commandKey = <span class="string">"getUserById"</span>, groupKey = <span class="string">"UserGroup"</span>, theadPoolKey = <span class="string">"getUserByIdThread"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(Long id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://USER-SERVICE/users/&#123;1&#125;"</span>, User.class, id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="请求缓存"><a href="#请求缓存" class="headerlink" title="请求缓存"></a>请求缓存</h3><p>系统用户不断增长时，每个微服务需要承受的并发压力也越来越大，进程间的服务请求调用会有一部分的性能损失。类似数据库的缓存保护也可以运用到依赖服务的调用上</p>
<h3 id="请求合并"><a href="#请求合并" class="headerlink" title="请求合并"></a>请求合并</h3><p>高并发下远程调用的通信消耗会很大，依赖服务的线程池资源有限，将出现排队等待和和相应延迟。<br>引入请求合并HystrixCollapser可以用来实现请求的合并，以减少通信消耗和线程占用。</p>
<p>HystrixCollapser在HystrixCommand之前放置一个合并处理器，对同一依赖服务的多个请求进行整合并以批量方式发起请求<br>假设微服务提供两个获取User的接口</p>
<pre><code>/users/{id}
/users?ids={ids}
</code></pre><p>消费端调用Service内有两个方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">find</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://USER-SERVICE/user/&#123;1&#125;"</span>,User.class,id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">(List&lt;String&gt; ids)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://USER-SERVICE/user/&#123;1&#125;"</span>,User.class,StringUtils.join(ids,<span class="string">","</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们要来实现将多个单一User对象的请求命令合并<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一个用于请求/users/&#123;id&#125;，一个用于请求/users?ids=&#123;ids&#125;</span></span><br><span class="line">    <span class="comment">//在/users/&#123;id&#125;上通过 @HystrixCollapser创建合并请求器，合并窗口时间100毫秒，超过100毫秒无法合并完成则不合并</span></span><br><span class="line">    <span class="meta">@HystrixCollapser</span>(batchMethod=<span class="string">"findAll"</span>,collapserProperties=&#123;</span><br><span class="line">        <span class="meta">@HystrixProperty</span>(name=<span class="string">"timerDelayInMilliseconds"</span>,value=<span class="string">"100"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">find</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@HystrixCommand</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">(List&lt;String&gt; ids)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://USER-SERVICE/user/&#123;1&#125;"</span>,User.class,StringUtils.join(ids,<span class="string">","</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/18/Spring Cloud：Spring Cloud Ribbon/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhuifengcc">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沐奕">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/18/Spring Cloud：Spring Cloud Ribbon/" itemprop="url">Spring Cloud：Spring Cloud Ribbon</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-18T12:54:39+08:00">
                2018-06-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring-Cloud/" itemprop="url" rel="index">
                    <span itemprop="name">Spring Cloud</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="客户端负载均衡"><a href="#客户端负载均衡" class="headerlink" title="客户端负载均衡"></a>客户端负载均衡</h2><p>Spring Cloud Ribbon是一个基于HTTP和TCP的客户端负载均衡，他基于Netflix Ribbon实现。通过Spring Cloud的封装，可以轻松地将面向服务的REST模板请求自动转换成客户端负载均衡的服务调用。</p>
<p>我们都知道，负载均衡是对系统的高可用、网络压力的缓解和处理能力扩容的重要手段之一。传统的服务端负载均衡的模块（硬件设备或者是软件模块）都会为维护一个下挂可用的服务端清单，通过心跳检测来剔除故障的服务端节点，当客户端发送请求到负载均衡设备的时候，该设备按某种算法（线性轮询、按权重负载、按流量负载等）从维护的服务端清单中取出一台服务端的地址，然后进行转发。</p>
<p>客户端负载均衡和服务端负载均衡最大的不同在于服务清单所存储的位置。在客户端负载均衡中，所有客户端节点都维护着自己要访问的服务端清单，而这些服务端清单来自服务注册中心，在客户端负载均衡中也需要心跳去维护服务端清单的健康性，只是这个步骤需要与服务注册中心配合完成。</p>
<p>如何实现客户端负载均衡？</p>
<pre><code>· 服务注册者只需要启动多个服务实例并注册到一个注册中心或是多个相关联的服务注册中心。
· 服务消费者直接通过调用被@LoadBalanced注解修饰过的RestTemple来实现面向服务的接口调用。
</code></pre><h2 id="RestTemple不同请求类型调用实现"><a href="#RestTemple不同请求类型调用实现" class="headerlink" title="RestTemple不同请求类型调用实现"></a>RestTemple不同请求类型调用实现</h2><h3 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h3><p>可通过两个方法进行调用实现</p>
<p>1、getForEntity(返回ResponseEntity对象，是Spring对HTTP请求响应的封装)</p>
<p>提供3个重载，具体可查询相关文档</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">ResponseEntity&lt;String&gt; responseEntity = restTemplate.getForEntity(<span class="string">"http://USER_SERVICE/user?name=&#123;1&#125;"</span>, String.class, <span class="string">"zhuifengcc"</span>)</span><br><span class="line">String body = responseEntity.getBody();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象User</span></span><br><span class="line">RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">ResponseEntity&lt;User&gt; responseEntity = restTemplate.getForEntity(<span class="string">"http://USER_SERVICE/user?name=&#123;1&#125;"</span>, User.class, <span class="string">"zhuifengcc"</span>)</span><br><span class="line">User userBody = responseEntity.getBody();</span><br></pre></td></tr></table></figure>
<p>2、getForObject(对getForEntity的进一步封装，通过HttpMessageConvererExtractor对HTTP的请求响应体body内容进行对象转换，实现请求直接返回包装好的对象内容)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">String result = restTemplate.getForObject(uri, String.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// body是一个对象时</span></span><br><span class="line">RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">User result = restTemplate.getForObject(uri, User.class);</span><br></pre></td></tr></table></figure>
<h3 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h3><p>可通过三个方法进行调用实现</p>
<p>1、getForEntity</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">User user = <span class="keyword">new</span> User(<span class="string">"zhuifengcc"</span>, <span class="number">24</span>);</span><br><span class="line"><span class="comment">// 提交的请求body是user对象，返回的响应body类型是String</span></span><br><span class="line">ResponseEntity&lt;User&gt; responseEntity = restTemplate.getForEntity(<span class="string">"http://USER_SERVICE/user"</span>, user, String.class)</span><br><span class="line">String body = responseEntity.getBody();</span><br></pre></td></tr></table></figure>
<p>2、getForObject</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">User user = <span class="keyword">new</span> User(<span class="string">"zhuifengcc"</span>, <span class="number">24</span>);</span><br><span class="line">String postResult = restTemplate.getForObject(<span class="string">"http://USER_SERVICE/user"</span>, user, String.class)</span><br></pre></td></tr></table></figure>
<p>这两者可同GET请求的发放进行类比</p>
<p>3、postForLocation(实现了以POST请求提交资源，并返回新资源的URI)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User(<span class="string">"zhuifengcc"</span>, <span class="number">24</span>);</span><br><span class="line">URI responseURI = restTemplate.postForLocation(<span class="string">"http://USER_SERVICE/user"</span>, user, String.class)</span><br></pre></td></tr></table></figure>
<p>由于返回新资源的URI，就相当于指定了返回类型。</p>
<h3 id="PUT请求"><a href="#PUT请求" class="headerlink" title="PUT请求"></a>PUT请求</h3><p>可通过PUT方法进行调用实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line"><span class="keyword">long</span> id = <span class="number">1001L</span>;</span><br><span class="line">User user = <span class="keyword">new</span> User(<span class="string">"zhuifengcc"</span>, <span class="number">24</span>);</span><br><span class="line">restTemplate.put(<span class="string">"http://USER_SERVICE/user/&#123;1&#125;"</span>, user, id);</span><br></pre></td></tr></table></figure>
<h3 id="DELETE请求"><a href="#DELETE请求" class="headerlink" title="DELETE请求"></a>DELETE请求</h3><p>可通过DELETE方法进行调用实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line"><span class="keyword">long</span> id = <span class="number">1001L</span>;</span><br><span class="line">restTemplate.delete(<span class="string">"http://USER_SERVICE/user/&#123;1&#125;"</span>, id);</span><br></pre></td></tr></table></figure>
<h2 id="Ribbon配置"><a href="#Ribbon配置" class="headerlink" title="Ribbon配置"></a>Ribbon配置</h2><p>Ribbon中定义的每一个接口都有多种不同的策略实现，同时这些接口之间又有一定的依赖关系，是的上手困难，不知道如何选择具体的实现策略及如何组织他们的关系，Spring Cloud Ribbon采用了自动化配置，引入Spring Cloud Ribbon的依赖之后，就能自动化构建这些接口的实现。</p>
<p>通过自动化配置的实现，可以轻松实现客户端负载均衡。同时，针对一些个性化需求，我们也可以方便地替换默认实现，只需在Spring Boot应用中创建对应的实现实例就能覆盖这些默认的实现。</p>
<h2 id="重试机制"><a href="#重试机制" class="headerlink" title="重试机制"></a>重试机制</h2><p>集成Spring Eureka时，由于Spring Eureka实现了CAP原理中的AP（满足可用性，分区容错性（可靠性），弱一致性），与Zookeeper实现CP（强一致性，可靠性）不同，Eureka为了实现更高的服务可用性，在极端情况下宁愿接受故障实例也不要丢掉”健康”实例。当服务注册中心故障时，Eureka在超过85%的实例丢失心跳时触发保护机制，注册中心将会保留此时所有节点，以实现服务间依然可以进行互相调用的场景，即使其中有部分故障节点，但是也可以继续保障大多数服务正常消费。</p>
<p>当触发了保护机制或者是服务剔除的延迟，引起服务调用到故障实例的时候，我们还是希望增强这类问题的容错，所以加入一些重试机制。Spring Cloud整合了Spring Retry来增强RestTemple的重试能力</p>
<pre><code>#开启重试机制
spring.cloud.loadbanlancer.retry.enabled=true
#断路器超时时间（需要大于Ribbon超时时间不然不会触发重试）
hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=10000
#请求连接的超时时间
hello-service.ribbon.ConnectTimeout=250
#请求处理的超时时间。
hello-service.ribbon.ReadTimeout=1000
#对所有操作请求都进行重试。
hello-service.ribbon.OkToRetryOnAllOperations=true
#切换实例的重试次数。
hello-service.ribbon.MaxAutoRetriesNextServer=2
#对当前实例的重试次数。
hello-service.ribbon.MaxAutoRetries=1
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/05/NoSQL：Redis入门介绍/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhuifengcc">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沐奕">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/05/NoSQL：Redis入门介绍/" itemprop="url">NoSQL：Redis入门介绍</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-05T17:07:44+08:00">
                2018-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NoSql/" itemprop="url" rel="index">
                    <span itemprop="name">NoSql</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Redis入门概述"><a href="#Redis入门概述" class="headerlink" title="Redis入门概述"></a>Redis入门概述</h2><h3 id="Redis是什么"><a href="#Redis是什么" class="headerlink" title="Redis是什么"></a>Redis是什么</h3><p>Redis：REmote DIctionary Server（远程字典服务器），是一个高性能的（key/value）分布式内存数据库，基于内存运行，并支持持久化的NOSQL数据库，也被人们称为数据结构数据库。</p>
<pre><code>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用
Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset（sorted set），hash等数据结构的存储
Redis支持数据的备份，即master-slave模式的数据备份
</code></pre><h3 id="Redis的安装"><a href="#Redis的安装" class="headerlink" title="Redis的安装"></a>Redis的安装</h3><p>我们在虚拟机上以centos为例进行Redis的安装：</p>
<p><img src="https://raw.githubusercontent.com/wiki/zhuifengcc/zhuifengcc.github.io/images/NoSQL/redis_1/2-1.png" alt="登录页面"></p>
<p>因为许久没有碰linux了，这里将整体过程及踩到的坑做一个记录：</p>
<p>默认安装好系统后时无法使用wget的，本打算用yum下载wget，再用wget完成对redis的下载，如下所示：</p>
<p><img src="https://raw.githubusercontent.com/wiki/zhuifengcc/zhuifengcc.github.io/images/NoSQL/redis_1/2-2.png" alt="直接运行wget页面"></p>
<p><img src="https://raw.githubusercontent.com/wiki/zhuifengcc/zhuifengcc.github.io/images/NoSQL/redis_1/2-3.png" alt="yum下载wget页面"></p>
<p>这是因为网络是不通的，需要配置网络，因为我使用的是笔记本的无线网络，虚拟机也需要同步使用，连接方式使用NAT尝试未成功，所以最后我将VMware连接方式调整成了桥接</p>
<p><img src="https://raw.githubusercontent.com/wiki/zhuifengcc/zhuifengcc.github.io/images/NoSQL/redis_1/2-4.png" alt="ping尝试"></p>
<p><img src="https://raw.githubusercontent.com/wiki/zhuifengcc/zhuifengcc.github.io/images/NoSQL/redis_1/2-5.png" alt="桥接配置"></p>
<p><img src="https://raw.githubusercontent.com/wiki/zhuifengcc/zhuifengcc.github.io/images/NoSQL/redis_1/2-6.png" alt="桥接配置"></p>
<p>查看物理机ip信息<br><img src="https://raw.githubusercontent.com/wiki/zhuifengcc/zhuifengcc.github.io/images/NoSQL/redis_1/2-7.png" alt="查看物理机ip"></p>
<p>根据物理主机的ip地址，设置linux虚拟机的ip地址:</p>
<p>方法：修改/etc/sysconfig/network-scripts/ifcfg-eth0这个配置文件</p>
<pre><code>vim /etc/sysconfig/network-scripts/ifcfg-eth0
DEVICE=eth0    #虚拟机网卡名称。
TYPE=Ethernet
ONBOOT=yes　　   #开机启用网络配置。
NM_CONTROLLED=yes
BOOTPROTO=static   #static，静态ip，而不是dhcp，自动获取ip地址。
IPADDR=192.168.1.109　　#设置我想用的静态ip地址，要和物理主机在同一网段，但又不能相同。
NETMASK=255.255.255.0 #子网掩码，和物理主机一样就可以了。
GETWAY=192.168.1.1  #和物理主机一样
DNS1=8.8.8.8　　　　　　#DNS，写谷歌的地址就可以了。
HWADDR=00:0c:29:22:05:4c
IPV6INIT=no
USERCTL=no  
</code></pre><p>在netwotk-scripts文件夹下，如果并没有所说的ifcfg-eth0这个文件，而是ifcfg-ens33还有ifcfg-lo, 通过vi命令编辑ens33这个文件，最后把文件改名就ok了, 必须有ifcfg-eth0这个配置文件<br><img src="https://raw.githubusercontent.com/wiki/zhuifengcc/zhuifengcc.github.io/images/NoSQL/redis_1/2-8.png" alt="网络配置目录"></p>
<p><img src="https://raw.githubusercontent.com/wiki/zhuifengcc/zhuifengcc.github.io/images/NoSQL/redis_1/2-9.png" alt="网络配置"></p>
<p>重命名：mv ifcfg-ens33 ifcfg-eth0</p>
<p><img src="https://raw.githubusercontent.com/wiki/zhuifengcc/zhuifengcc.github.io/images/NoSQL/redis_1/2-10.png" alt="网络配置"></p>
<p>如果你没有ifcfg-eth,是改ens33的，还需要下面俩步</p>
<p>用vi命令编辑/etc/default/grub 并在GRUBCMDLINELINUX变量加入“net.ifnames=0 biosdevname=0 ”，如下</p>
<p><img src="https://raw.githubusercontent.com/wiki/zhuifengcc/zhuifengcc.github.io/images/NoSQL/redis_1/2-11.png" alt="网络配置"></p>
<p>修改完之后，按ESC，然后输入 ：wq（加！表示保存只读文件的修改）退出</p>
<p>运行命令grub2-mkconfig -o /boot/grub2/grub.cfg 来重新生成GRUB配置并更新内核参数。</p>
<p>最后重启 reboot</p>
<p>重启后可以尝试ping外网，发现此时网络可以连通了，于是可以通过yum下载wget，然后通过wget下载redis了，将redis下载到/opt下</p>
<p><img src="https://raw.githubusercontent.com/wiki/zhuifengcc/zhuifengcc.github.io/images/NoSQL/redis_1/2-12.png" alt="尝试ping"></p>
<p><img src="https://raw.githubusercontent.com/wiki/zhuifengcc/zhuifengcc.github.io/images/NoSQL/redis_1/2-13.png" alt="yum下载wget"></p>
<p><img src="https://raw.githubusercontent.com/wiki/zhuifengcc/zhuifengcc.github.io/images/NoSQL/redis_1/2-14.png" alt="yum下载wget"></p>
<p><img src="https://raw.githubusercontent.com/wiki/zhuifengcc/zhuifengcc.github.io/images/NoSQL/redis_1/2-15.png" alt="wget下载redis"></p>
<p><img src="https://raw.githubusercontent.com/wiki/zhuifengcc/zhuifengcc.github.io/images/NoSQL/redis_1/2-16.png" alt="wget下载redis"></p>
<p><img src="https://raw.githubusercontent.com/wiki/zhuifengcc/zhuifengcc.github.io/images/NoSQL/redis_1/2-17.png" alt="redis解压"></p>
<p>下载完毕并解压后，进入/opt/redis-4.0.8目录，可以看到redis.conf配置文件，我们将文件拷贝一份至根目录新建的文件夹myredis下以做备份，使用vi命令(less -MN)打开备份的redis.conf文件，在general部分可以看到如下配置，默认redis不会以进程的方式存在，为了后续测试，我们将该属性修改为yes并保存退出</p>
<p><img src="https://raw.githubusercontent.com/wiki/zhuifengcc/zhuifengcc.github.io/images/NoSQL/redis_1/2-18.png" alt="配置文件备份"></p>
<p><img src="https://raw.githubusercontent.com/wiki/zhuifengcc/zhuifengcc.github.io/images/NoSQL/redis_1/2-19.png" alt="配置文件备份"></p>
<p><img src="https://raw.githubusercontent.com/wiki/zhuifengcc/zhuifengcc.github.io/images/NoSQL/redis_1/2-20.png" alt="修改配置"></p>
<p>回到我们解压后的redis的目录，我们对redis进行安装，可以看到目录下有MAKEFILE文件，运行make命令进行编译</p>
<p><img src="https://raw.githubusercontent.com/wiki/zhuifengcc/zhuifengcc.github.io/images/NoSQL/redis_1/2-21.png" alt="make编译"></p>
<p><img src="https://raw.githubusercontent.com/wiki/zhuifengcc/zhuifengcc.github.io/images/NoSQL/redis_1/2-22.png" alt="make编译"></p>
<p>此时可以看到运行出错，gcc command not find, gcc是用以编译c/c++项目，与java中的javac类似，这个gcc东东貌似在学校的时候碰到过，好啦，那就是我们目前系统中缺少gcc，我们yum安装它即可</p>
<p><img src="https://raw.githubusercontent.com/wiki/zhuifengcc/zhuifengcc.github.io/images/NoSQL/redis_1/2-23.png" alt="yum下载gcc"></p>
<p><img src="https://raw.githubusercontent.com/wiki/zhuifengcc/zhuifengcc.github.io/images/NoSQL/redis_1/2-24.png" alt="gcc安装完成"></p>
<p>安装完毕后在我们解压的redis目录下再次make</p>
<p><img src="https://raw.githubusercontent.com/wiki/zhuifengcc/zhuifengcc.github.io/images/NoSQL/redis_1/2-25.png" alt="再次make编译"></p>
<p><img src="https://raw.githubusercontent.com/wiki/zhuifengcc/zhuifengcc.github.io/images/NoSQL/redis_1/2-26.png" alt="再次make编译"></p>
<p>可以看到又报错了，这是搞事情啊，原因在于上次make之后我们的相关目录没有clean干净，可以通过运行make distclean 解决</p>
<p><img src="https://raw.githubusercontent.com/wiki/zhuifengcc/zhuifengcc.github.io/images/NoSQL/redis_1/2-27.png" alt="make distclean"></p>
<p><img src="https://raw.githubusercontent.com/wiki/zhuifengcc/zhuifengcc.github.io/images/NoSQL/redis_1/2-28.png" alt="再次make"></p>
<p>执行完毕后我们再次make，可以看到这一次正常make完成了，并且redis给我们了一个提示：”It’s a good idea to run ‘make test’”</p>
<p><img src="https://raw.githubusercontent.com/wiki/zhuifengcc/zhuifengcc.github.io/images/NoSQL/redis_1/2-29.png" alt="make编译成功"></p>
<p>最后还需要执行make install完成最后的安装</p>
<p><img src="https://raw.githubusercontent.com/wiki/zhuifengcc/zhuifengcc.github.io/images/NoSQL/redis_1/2-30.png" alt="make install"></p>
<p><img src="https://raw.githubusercontent.com/wiki/zhuifengcc/zhuifengcc.github.io/images/NoSQL/redis_1/2-31.png" alt="安装完成"></p>
<p>至此，redis的安装就完成了</p>
<p>在默认安装目录/usr/local/bin下我们可以看到生成了下列的文件,可以运行我们备份修改的conf文件使得redis以进程的形式跑起来，同时也可以查看redis相关的进程开启情况，以及通过执行redis-brenchmark来查看部署redis的机器的相关情况，如最大支持的读写数等</p>
<p><img src="https://raw.githubusercontent.com/wiki/zhuifengcc/zhuifengcc.github.io/images/NoSQL/redis_1/2-32.png" alt="安装目录附图"></p>
<p><img src="https://raw.githubusercontent.com/wiki/zhuifengcc/zhuifengcc.github.io/images/NoSQL/redis_1/2-33.png" alt="运行redis进程附图"></p>
<pre><code>服务端启动（指定配置文件启动）./bin/redis-server [path]
设置了密码的时候，客户端命令：redis-cli -h host -p port -a password
</code></pre><p>执行ps -ef|grep redis 查看redis进程的运行前后对比情况</p>
<p><img src="https://raw.githubusercontent.com/wiki/zhuifengcc/zhuifengcc.github.io/images/NoSQL/redis_1/2-34.png" alt="进程查看附图"></p>
<p>以上就是redis整个的安装过程，后续对redis的数据结构进行整合和记录</p>
<h3 id="Redis的配置文件"><a href="#Redis的配置文件" class="headerlink" title="Redis的配置文件"></a>Redis的配置文件</h3><pre><code>1.Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程
  daemonize no
2.当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid，可以通过pidfile指定
  pidfile /var/run/redis.pid
3.指定Redis监听端口，默认端口为6379(MERZ)
  port 6379
4.绑定的主机地址
  bind 127.0.0.1
5.当客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能
  timeout 300
6.指定日志记录级别，Redis总共支持四个级别: debug, verbose, notice, warning，默认为verbose
  loglevel verbose
7.日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null
  logfile stdout
8.设置数据库的数量，默认数据库为0，可以使用SELECT &lt;dbid&gt;命令在连接上指定数据库id
  databases 16
9.指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合
  save &lt;seconds&gt; &lt;changes&gt;
  Redis 默认配置文件中提供了三个条件
  save 900 1  900秒（15分钟）内有1个更改
  save 300 10  300秒（5分钟）内有10个更改
  save 60 10000  60秒内有10000个更改
  ps: 若没有同步（持久化），如非正常关闭Redis，未持久化成功的key将丢失
10.指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大
  rdbcompression yes
11.指定本地数据库文件名，默认值为dump.rdb
  dbfilename dump.rdb
12.指定本地数据库存放目录
  dir ./
13.设置当本机为slave服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步
  slaveof &lt;masterip&gt; &lt;masterport&gt;
14.当master服务设置了密码保护时，slave服务连接master的密码
  masterauth &lt;master-password&gt;
15.设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH &lt;password&gt;命令提供密码，默认关闭
  requirepass 123
16.设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置maxclients 0，表示不作限制。当客户端连接数达到限制时，Redis会关闭新的连接并向客户返回 max number of clients reached错误信息
  maxclients 128
17.指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的key，当此方法处理后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把key存放内存，Value会存放在swap区
  maxmemory &lt;bytes&gt;
18.指定是否在每次更新后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为Redis本身同步数据文件时按上面save条件来同步的，所以有的数据会在一段时间只存在与内存中，默认为no
  appendonly no
19.指定更新日志文件名，默认为appendonly.aof
  appendfilename appendonly.aof
20.指定日志更新条件，共有3个可选值：
  no: 表示等操作系统进行数据缓存同步到磁盘（快）
  always: 表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）
  everysec: 表示每秒同步一次（折中，默认值）
  appendfsync everysec
21.指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中
  vm-enabled no
22.虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享
  vm-swap-file /tmp/redis.swap
23.将所有大于vm-max-memory的数据存入虚拟内存，无论vm-max-memory设置多小，所有索引数据都是内存存储的（Redis的索引数据， 就是keys）。也就是说，当vm-max-memory设置为0的时候，其实是所有value都存在与磁盘。默认值为0
  vm-max-memory 0
24.Redis swap文件分成了挺多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的数据大小来设定的，建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不确定，就使用默认值
  vm-page-size 32
25.设置swap文件中的page数量，由于页表（一种表示页面空间或使用的bitmap）是放在内存中的，在磁盘上每8个pages将消耗1byte的内存
  vm-pages 134217728
26.设置访问swap文件的线程数，最好不要超过机器的核数，如果设置为0，那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4
  vm-max-threads 4
27.设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启
  glueoutputbuf yes
28.指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法
  hash-max-zipmap-entries 64
  hash-max-zipmap-value 512
29.指定是否激活重置哈希，默认为开启
  activerehashing yes
30.指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件
  include /path/to/local.conf
31.Redis作为优秀的中间缓存件，时常会存储大量的数据，即使采取了集群部署来动态扩容，也应该即时的整理内存，维持系统性能（如果数据一直新增，内存很快就会占满）
  在Redis中有两种解决方案
  一是为数据设置超时时间，
  设定内存空间，建议内存不要超过1G 256-512M
  二是采用LRU算法动态将不用的数据删除。内存管理的一种页面置换算法，对于在内存中但又不用的数据块（内存块）叫做LRU，操作系统会根据哪些数据属于LRU而将其移出内存而腾出控件来加载另外的数据。
  1.volatile-lru: 设定超时时间的数据中，删除最不常使用的数据
  2.allkeys-lru: 查询所有的key中最不常使用的数据进行删除，这是应用最广泛的策略
  3.volatile-random: 在已经设定了超时的数据中随机删除
  4.allkeys-random: 查询所有的key之后随机删除
  5.volatile-ttl: 查询全部设定超时时间的数据，之后排序，将马上将要过期的数据进行删除操作
  6.Noeviction: 如果设置为该属性，则不会进行删除操作，如果内存溢出则报错返回
  7.volatile-lfu: 从所有配置了过期时间的键中驱逐使用频率最少的键
  8.allkeys-lfu: 从所有键中驱逐使用频率最少的键
</code></pre><h3 id="Redis的关闭"><a href="#Redis的关闭" class="headerlink" title="Redis的关闭"></a>Redis的关闭</h3><pre><code>非正常关闭，数据容易丢失
  ps -ef | grep -i redis
  kill -9 pid
正常关闭，数据保存
  ./bin/redis-cli shutdown
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">zhuifengcc</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhuifengcc</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
